SUBROUTINE SERCH; (CHANEL,REDRED,KEY,STPOS1,ENPOS1,BSEND,BSMID,SRCCTL,SRCOPT,
;			RCNOST,RCNOEN,STPOS2,ENPOS2,STPOS3,ENPOS3)
;
;:
;
;		STANDARD SEARCH MODULE
;		DOES BINARY SEARCH OR SEQUENTIAL SEARCH
;		CHECKS FOR RECORDS FLAGGED FOR DELETION
;		OPTIONS TO PRINT WAIT MESSAGE & CLEAR SCREEN
;		ALLOWS OPTIONAL ABORT IF LOCKED RECORD IS ENCOUNTERED
;
	CHANEL	,D	;CHANNEL ON WHICH FILE IS TO BE READ
	REDREC	,A	;PARAMETER IN WHICH FOUND RECORD IS PASSED BACK
	KEY	,A	;KEY YOU'RE LOOKING FOR
	STPOS1	,D	;STARTING POSITION OF KEY FIELD #1
	ENPOS1  ,D	;ENDING POSITION OF KEY FIELD #1
	BSEND	,D	;COUNT OF SORTED RECORDS IN FILE
	BSMID	,D	;MID POINT (RECORD READ)
	SRCCTL	,D	;POST EXECUTION BRANCH CODES
			;	0 = RECORD FOUND
			;	1 = RECORD NOT FOUND
			;	2 = RECORD LOCKED AND ABORT CHOSEN
			;INCOMING SPECIAL FILE TYPE CODE
			;	2 = NON-INDEX FILE
			;	3 = INDEX FILE, ALLOW ABORT ON LOCKED RECORD
			;	4 = NON-INDEX FILE, ALLOW ABORT "       "
	SRCOPT	,D	;INCOMING OPTION CODE (SEE BELOW)
	RCNOST	,D	;START POSITION OF FIELD WHERE RECORD IS FLAGGED
			;FOR DELETION
	RCNOEN	,D	;END POSITON OF FIELD WHERE RECORD IS FLAGGED
			;FOR DELETION
	STPOS2	,D	;STARTING POSITION OF KEY FIELD #2
	ENPOS2	,D	;ENDING POSITION OF KEY FIELD #2
	STPOS3  ,D	;STARTING POSITON OF KEY FIELD #3
	ENPOS3	,D	;ENDING POSITION OF KEY FIELD #3
RECORD
	ABORT	,D1
	BRACKS	,A10,	']]]]]]]]]]'
	BSHI	,D6	;HIGH VALUE FOR SEARCH
	BSLO	,D6	;LOW VALUE FOR SEARCH
	BSMKEY	,A50	;KEY OF RECORD READ
	SUB1	,D3	;WORK INDEX #1
	SUB2	,D3	;WORK INDEX #2
	DELETD	,A6	;LITERAL VALUE OF DELETED FIELD
	ERR	,D3	;ERROR # ARGUMENT FOR XCALL ERROR
	ERL	,D5	;ERROR LINE ARGUMENT FOR XCALL ERROR
	RDCNTR	,D1
	SYSTEM	,D1
	TCHAR	,D3
	TCHAR2	,D3

			;***** OPTION CODES *****
			;	1 = DISPLAY "PLEASE WAIT" MESSAGE, BINARY
			;		SEARCH, CLEAR WAIT MESSAGE
			;	2 = BINARY SEARCH, CLEAR WAIT MESSAGE
			;	3 = DISPLAY "PLEASE WAIT" MESSAGE, BINARY
			;		SEARCH
			;	4 = BINARY SEARCH
			;	5 = SEQUENTIAL SEARCH (BSMID SPECIFIES
			;		STARTING RECORD #)
			;	6 = GENERIC SEARCH (POSITION BSMID AT OR
			;		AFTER KEY VALUE)

PROC
	DELETD = '000000'
	IF (SRCCTL.EQ.2 .OR. SRCCTL.EQ.4) DELETD = ']]]DEL'
	ABORT =
	IF (SRCCTL.EQ.3 .OR. SRCCTL.EQ.4) ABORT = 1
	BSMKEY =
	SRCCTL =
	RDCNTR =
	ON ERROR RDERR
	GO TO (SERCH1,SERCH2,SERCH3,SERCH4,SEQSCH,SERCH1), SRCOPT
;-------------------------------------------------------------------------------
SERCH1,							;OPTION 1 (SEE ABOVE)
	CALL WAIT
	CALL SEARCH
	CALL CLEAR
	RETURN
SERCH2,							;OPTION 2 (SEE ABOVE)
	CALL SEARCH
	CALL CLEAR
	RETURN
SERCH3,							;OPTION 3 (SEE ABOVE)
	CALL WAIT
	CALL SEARCH
	RETURN
SERCH4,							;OPTION 4 (SEE ABOVE)
	CALL SEARCH
	RETURN
;-------------------------------------------------------------------------------
WAIT,							;DISPLAYS WAIT MESSAGE
	XCALL OUTPT (24,1,1,'PLEASE WAIT ...',1)
	RETURN
;-------------------------------------------------------------------------------
SEARCH,
	BSHI = BSEND				;BSEND SET TO HIGH SORTED RECORD
	BSLO =					;BEFORE ENTERING SUBROUTINE
MIDPT,
	BSMID = (BSHI+BSLO+1)/2				;COMPUTE MID VALUE
	CALL READ
	GO TO (RETURN), SRCCTL - 1
	IF (BSMKEY.EQ.KEY) GO TO GTFRST			;MATCHED KEYS, GET FIRST
	IF (BSMID.EQ.BSHI.OR.BSMID.EQ.BSLO) GO TO BSNOM	;RECORD NOT FOUND
	IF (BSMKEY.GT.KEY) BSHI = BSMID			;SET NEW HIGH VALUE
							;TO MID VALUE
	IF (BSMKEY.LT.KEY) BSLO = BSMID			;SET NEW LOW VALUE
							;TO MID VALUE
	GO TO MIDPT
;-------------------------------------------------------------------------------
BSNOM,							;START OF SEQUENTIAL
							;SEARCH OF OVERFLOW AREA
	IF (SRCOPT.EQ.6) GO TO POSITN
	BSMID = BSEND
	INCR BSMID
SEQSCH,							;OPTION 5 (SEE ABOVE)
	CALL READ
	GO TO (RETURN,RETURN), SRCCTL			;RECORD NOT FOUND
	IF (BSMKEY.EQ.KEY.AND.REDREC(RCNOST,RCNOEN).NE.DELETD) GO TO RETURN
							;RECORD FOUND
	INCR BSMID
	GO TO SEQSCH
;-------------------------------------------------------------------------------
NOMACH,
	SRCCTL = 1					;FLAG RECORD NOT FOUND
RETURN,
	IF (SRCOPT.GE.3) RETURN
CLEAR,							;CLEARS WAIT MESSAGE
	XCALL OUTPT (24,1,1,'\',1)
	RETURN
;-------------------------------------------------------------------------------
READ,
	READ (CHANEL,REDREC,BSMID)
	UNLOCK CHANEL
	IF (REDREC.EQ.BRACKS) GO TO NOMACH		;END-OF-FILE CONDITION
	SUB1 = 1					;CREATE KEY #1
	SUB2 = ENPOS1-STPOS1+SUB1
	BSMKEY(SUB1,SUB2) = REDREC(STPOS1,ENPOS1)
	IF (STPOS2.EQ.0) RETURN
	SUB1 = SUB2+1					;CREATE KEY #2
	SUB2 = ENPOS2-STPOS2+SUB1
	BSMKEY(SUB1,SUB2) = REDREC(STPOS2,ENPOS2)
	IF (STPOS3.EQ.0) RETURN
	SUB1 = SUB2+1					;CREATE KEY #3
	SUB2 = ENPOS3-STPOS3+SUB1
	BSMKEY(SUB1,SUB2) = REDREC(STPOS3,ENPOS3)
	RETURN
;-------------------------------------------------------------------------------
GTFRST,							;BACK UP TO FIRST MATCH
	BSMID = BSMID - 1
	IF (BSMID.EQ.0) GO TO FORWRD
	CALL READ
	GO TO (RETURN), SRCCTL - 1
	IF (BSMKEY.EQ.KEY) GO TO GTFRST
FORWRD,							;FIND FIRST VALID MATCH
	INCR BSMID
	CALL READ
	GO TO (RETURN), SRCCTL - 1
	IF (BSMKEY.NE.KEY) GO TO BSNOM		;NO MATCH-SEARCH OVERFLOW
	IF (REDREC(RCNOST,RCNOEN).EQ.DELETD) GO TO FORWRD
	GO TO RETURN
POSITN,
	IF (BSMID.EQ.BSLO.OR.BSMID.LE.1) INCR BSMID
	READ (CHANEL,REDREC,BSMID)
	IF (REDREC(RCNOST,RCNOEN).EQ.DELETD) INCR BSMID
	IF (REDREC(RCNOST,RCNOEN).EQ.DELETD) GO TO POSITN
	IF (REDREC.EQ.']]]]]]') SRCCTL = 1
	IF (BSMID.GT.BSEND) SRCCTL = 1
	UNLOCK CHANEL
	RETURN
RDERR,
	XCALL ERROR(ERR,ERL)
	IF (ERR.NE.40) GO TO NOMACH	;NO MATCH EXCEPT FOR LOCKED RECORD
	INCR RDCNTR
	IF (RDCNTR.LT.9) GO TO SLEEP
	RDCNTR =
	IF (ABORT.EQ.0) GO TO READ
	XCALL ENVRN (SYSTEM)
	IF (SYSTEM.GT.1) SYSTEM = 1	;MAINTAIN TSX+ = 1
	XCALL OUTPT (24,1,1,'RECORD TEMPORARILY IN USE - WILL YOU WAIT ?   ',1)
DELETE,
	XCALL OUTPT (0,0,-1,'DELETE',1)
	XCALL FLAGS (00010000,1)	; SUPPRESS CHARACTER ECHO
ACCEPT,
	IF (SYSTEM.NE.1) GO TO CONTIN
	DISPLAY (15,29,'F',29,'Q',1)	; SET ACTIVATION ON FIRST CHARACTER
CONTIN,
	ACCEPT (15,TCHAR)
	IF (TCHAR.NE.89 .AND. TCHAR.NE.78) GO TO ACCEPT
	IF (TCHAR.EQ.89) XCALL OUTPT (24,46,0,'Y',1)
	IF (TCHAR.EQ.78) XCALL OUTPT (24,46,0,'N',1)
ACCEP2,
	ACCEPT (15,TCHAR2)
	IF (TCHAR2.EQ.127) GO TO DELETE
	IF (TCHAR2.NE.13) GO TO ACCEP2
	IF (SYSTEM.NE.1) ACCEPT (15,TCHAR2)
	XCALL FLAGS (00010000,0)
	IF (SYSTEM.EQ.1) DISPLAY (15,29,'E')
	IF (TCHAR.EQ.78) GO TO ABORT
        XCALL OUTPT (24,1,1,'\',1)
SLEEP,
	SLEEP 1
	GO TO READ
ABORT,
	SRCCTL = 2
	RETURN
END
