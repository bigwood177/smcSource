;  SORT / UTL
;
;
;		::PCPYUTL.DEF::
;*****************************************************************************
;		SECURITY SYSTEM UTILITIES AND SUBROUTINES 
;		DIBOL FOR RT-11
;		
;		RELEASED: JANUARY 1, 1985
;*****************************************************************************
;
;
;		PROPRIETARY RIGHTS NOTICE:  All rights reserved.  This
;		material contains the valuable properties and trade secrets
;		of MCBA, Glendale, California, USA embodying substantial
;		creative effort and confidential information and ideas, no
;		part of which may be used and/or disclosed without MCBA's
;		duly authorized license agreement and/or written permission.
;
;		COPYRIGHT NOTICE:  Copyright <C> 1978, 1981, 1982, 1983, 1984,
;		1985, MCBA, AN UNPUBLISHED WORK.  ALL RIGHTS RESERVED.
;
;
;		COMPILE & LINK PER INSTALLATION OR TECHNICAL NOTES.
;
;:
;
;*************************************************************************
;	I M P O R T A N T   N E W   F E A T U R E S
;*************************************************************************
;
;  SORT.MAN now assumes "SRT" for the sort work space
;  default assignments.  Hard-coded devices in sort control files
;  can override this feature.
;
;  SORT.UTL is identical to SORT.MAN except that it uses subroutine 
;  arguments that are compatible with the .UTL subroutines.  SORT.UTL 
;  is only intended for use in sorting the SECURE.DDF file.  The
;  SRTSEC.UTL sort control file uses a SECURITY statement instead of 
;  a SYSTEM statement.
;
;  If the "SYSTEM" statement is used in the sort control file,
;  then the 2nd screen line (upon execution) will display the
;  word "SORT FILE" followed by the full file specification of the
;  file being sorted.  If a different output file designation was also
;  used in the sort control file, the word "INTO" and the output file
;  specification is also displayed after the input file-spec.
;
;  If input and output files are the same, an x-merge is performed
;  after the work files are in sorted order.  If an abort of an
;  executing SORT program  occurs, the original file will remain intact
;  if the abort occurrs before the final merge phase.  This version of
;  "SORT" will automatically change the re-start switch in the message
;  file before the merge phase begins.  This should prevent the user
;  from indiscriminately re-starting an aborted SORT.
;
;  When the merge phase is started (internally) , the message "MERGE PHASE"
;  is displayed after the above messages, and the re-start switch is set to
;  zero.  An abort during the merge can cause unpredictable results in your
;  data file outputted from the SORT.
;
;  See notes in GSORT.UTL also.
;
;  This version of "SORT" traps control-C'S from the terminal.
;
;  This version of Sort is SORT and supports multiple sorting methods.
;  The control record of MESARA is checked and the following sort will
;  be performed depending upon the value of DSRTTYP:
;  0 = regular DIBOL sort
;  1 = CTS-300 Macro sort (SORT.SAV or SORT.TSD)
;  2 = RTSORT
;**********************************************************************
;
;	G E N E R A L   D E S C R I P T I O N
;
;	THE BASIC ALGORITHMS FOR THIS SORT ARE TAKEN FROM THE BOOK
;	-THE ART OF COMPUTER PROGRAMMING, VOLUME 3/ SORTING AND SEARCHING-,
;	BY DONALD E.KNUTH, ADDISON-WESLEY PUBLISHING CO.
;	THIS SORT USES A NATURAL TWO-WAY MERGE-SORT (KNUTH,P.161) FOR
;	INTERNAL SORTING, AND A POLYPHASE MERGE (KNUTH,P.270) FOR THE
;	EXTERNAL MERGE PHASE. THE STATEMENT LABELS STARTING WITH N CORRESPOND
;	TO THE STEPS OF THE ALGORITHM FOR THE NATURAL TWO-WAY MERGE SORT
;	GIVEN IN KNUTH,P.161. THE LABELS STARTING WITH D CORRESPOND
;	TO THE STEPS OF THE ALGORITHM FOR THE POLYPHASE MERGE GIVEN
;	IN KNUTH P.270.  THE INTERNAL MERGE SORTING IS DONE IN A
;	SPLIT BUFFER CALLED BUFF.
;
;		EOSREC=END OF STRING RECORD. THE END OF A SORTED STRING
;		 IS MARKED BY A RECORD WHICH IS SORTED ALONG WITH THE
;		 DATA RECORDS.
;		NWRK  = NUMBER OF WORKFILES.
;		P = (NWRK-1) .  P IS THE MAXIMUM NUMBER OF SORTED STRINGS
;		 THAT ARE MERGED AT ANY ONE TIME.
;		DUMMY (I)  = NUMBER OF DUMMY STRINGS ASSUMED TO BE ON
;		 WORK FILE I.
;		A (I)  = COUNTER USED IN DISTRIBUTING SORTED STRINGS
;		 TO WORK FILES.
;		MRGCHN (I) =ARRAY WHICH GIVES THE ACTUAL CHANNELS THAT ARE
;		 INVOLVED IN A PARTICULAR MERGE DURING THE MERGE PHASE.
;		RUNCNT (I) =NUMBER OF SORTED STRINGS ON WORKFILE I.
;		RUNLEN=NUMBER OF INPUT RECORDS IN ONE BUFFER LOAD.
;		WRTCHN=CHANNEL THAT THE FINAL WRITE IS DONE ON, IN A KEYSORT.
;		RDCHN=CHANNEL THAT THE UNSORTED RECORDS ARE READ FROM,
;		 USING THE SORTED KEYFILE, WHICH ARE THEN WRITTEN IN
;		 CORRECT SEQUENCE ON WRTCHN.
;
RECORD
	,A64,'THIS MATERIAL CONTAINS THE VALUABLE PROPERTIES AND TRADE SECRETS'
	,A62,'OF MCBA, EMBODYING CONFIDENTIAL INFORMATION AND IDEAS, NO PART'
	,A56,'OF WHICH MAY BE USED AND/OR DISCLOSED WITHOUT MCBAs DULY'
	,A55,'AUTHORIZED LICENSE AGREEMENT AND/OR WRITTEN PERMISSION.'
	,A61,'COPYRIGHT (C) MCBA, AN UNPUBLISHED WORK. ALL RIGHTS RESERVED.'

RECORD FILBL		;FILE LABEL FOR SOURCE AND DESTINATION FILES.
	FILNME	,A14
		,A1,'['
	SIZE	,D5			;BLOCK SIZE UPON FILE OPEN.
		,A1,']'
RECORD
	FSTFLG	,D1,1			;FIRST INPUT BUFFER FLAG
	LOKEY	,D1			;LOW KEY IN KEY COMPARISON
	MRGFLG	,D1,1			;INDICATES IF ANY MERGING
					;HAS TAKEN PLACE.
	ENDRUN	,D3			;ACTUAL END OF RUN IN BUFFER
	SWFL	,8D1,1,1,1,1,1,1,1,1	;FLAGS INDICATING READ OR WRITE
					;FROM BEGINNING OF FILE.
RECORD FILDTA		;DATA SENT BY A PRECEDING PROGRAM.
.IFDEF SYSTEM
	PRGNAM	,A9			;PROGRAM TO BE EXECUTED NEXT
.ENDC
.IFNDEF SYSTEM
  .IFDEF SEC20
	PRGNAM  ,A9
  .ENDC
  .IFNDEF SEC20
	PRGNAM	,A14
  .ENDC
.ENDC
	RECCNT	,D5			;NUMBER OF RECORDS IN INPUT FILE
	ORGCNT	,D5			;NO. OF RECORDS ALREADY IN ORDER
					;AT BEGINNING OF INPUT FILE.
RECORD WRKFIL		;WORK FILE LABEL
	WRKDEV	,A3
		,A1,':'
	WRKNAM	,A6
		,A1,'.'
	WRKEXT	,A4,'WK ['
	SIZE1	,D5
		,A1,']'
RECORD MESARA
			.INCLUDE 'DEF:MES001.DEF'
RECORD,X
			.INCLUDE 'DEF:MES002.DEF'

RECORD
	WRKCHN	,7D1,1,2,3,4,5,6,7	;USED TO CYCLICALLY RENUMBER WORK
					;FILE CHANNELS DURING MERGE PHASE.
	SWKCHN	,D1			;THESE 3 VARIABLES SAVE 3 VALUES
					;WHICH ARE USED A FEW STATEMENTS LATER
	SDUMMY	,D3
	SRNCNT	,D4
	AA	,D3			;VARIABLE USED IN DISTRIBUTION
					;OF SORTED STRINGS.
RECORD
	SEQNO	,D5			;SEQUENCE NUMBER OF RECORD HAVING
					;THIS KEY (KEY SORT) .
	J1	,D1			;INDEX
	J	,D1			;INDEX
	L	,D5			;BUFFER POINTER
	I	,D5			;BUFFER POINTER
	S	,D1			;WHICH HALF OF SPLIT BUFFER RECORDS
					;ARE MOVED TO.
	K	,D5			;BUFFER POINTER
	F	,D1			;INDICATES END OF SORT OF
					;CURRENT BUFFER.
	JJ	,D5			;BUFFER POINTER
	MOVPNT	,D1			;+1 IF MOVING FROM BOTTOM OF BUFFER,
					;-1 IF FROM TOP OF BUFFER
	LL	,D3			;LEVEL NUMBER IN DISTRIBUTION
					;OF SORTED STRINGS
	CHANS	,D1			;HOW MANY CHANNELS STRINGS ARE
					;BEING MERGED FROM
	KK	,D5			;SAVES VALUE OF K
	XX	,D1			;WORK INDEX
	XY	,D1			;WORK INDEX
	XZ	,D1			;WORK INDEX
	BLANKS	,A10
RECORD
	ENDFLG	,D1			;END OF INPUT
	RECS	,D5			;COUNTER
	LOUNIT	,D1			;WHICH STRING HAS LOW RECORD
					;IN THE MERGE
	ERNO	,A2
	INREC	,D5			;ACTUAL NUMBER OF RECORDS READ
					;
					; SORT GENERATOR DETERMINES
					; N IN PROC (N)
COMMON
			.INCLUDE 'DEF:COM001.DEF'

RECORD
	BLANK	,A1
	TERMNO	,D2
	SYTTNO	,D4
	MCTTNO	,D2
	TTNOSW	,D1
	DPNTR	,D3
	CPNTR	,D1
	CNT1	,D3
	CNT2	,D3
	CMWCNT	,D2		; COUNTER USED FOR DISPLAYING DEVICE ASSIGNS
	FILSPC	,A21		; SQUEEZED VERSION OF FILBL
	FILSPW	,A21		; SQUEEZED VERSION OF WRKFIL
	MSGSWT	,D1		; SWITCH USED FOR MESSAGE SEND/RECEIVE
	TMPSRT	,A200		; WORKING FIELD USED TO SQUEEZE MACRO SORT 
				; MESSAGES
	V	,D2

;****************************************

.IFDEF PROC1
PROC (1)
.ENDC
.IFDEF PROC2
PROC (2)
.ENDC
.IFDEF PROC3
PROC (3)
.ENDC
.IFDEF PROC4
PROC (4)
.ENDC
.IFDEF PROC5
PROC (5)
.ENDC
.IFDEF PROC6
PROC (6)
.ENDC
;****************************************

.IFDEF SEC20
	CNPOS = -2		;TO ALLOW PROGRAM TO RUN WITHOUT BEING 
				;LOGGED INTO THE SYSTEM
.ENDC
	XCALL TERID 
	SYTTNO = TNMBR - 2		;SAVE VALUE RETURNED BY TNMBR FOR
					;SEND STATEMENT USED FOR MACRO SORTS
	XCALL FLAGS (10000000,1)	;TRAP CONTROL-C FROM THE TERMINAL.

;****************************************

.IFNDEF DEST
	BUFF (1,6) = SOURCE (5,10)
.ENDC

.IFDEF DEST
	BUFF (1,6) = DEST (5,10)
.ENDC

.IFDEF SYSTEM

	MSGSWT = -1
	XCALL FFILE (DEVIN,SOURCE,MSGSWT)
	IF (MSGSWT) GO TO ERMSG1
	XCALL OUTPT (2,1,1,'SORT FILE ')
	XCALL OUTPT (0,0,0,SOURCE)
.ENDC
;****************************************

.IFDEF DEST
  .IFDEF SYSTEM
	MSGSWT = -1
	XCALL FFILE (DEVOUT,DEST,MSGSWT)
	IF (MSGSWT) GO TO ERMSG3
	XCALL OUTPT (0,0,0,' INTO FILE ')
	XCALL OUTPT (0,0,0,DEST)
  .ENDC
.ENDC
;****************************************

	MSGSWT = 1			;RECEIVE MESSAGE
	XCALL SNMSG (FILDTA,MSGSWT)
.IFDEF SYSTEM
	IF (MSGSWT.EQ.9) GOTO ERMSG5	;IF WITHIN MCBA SYSTEM, ERROR
.ENDC

;****************************************

.IFDEF CHAIN				;DYNAMIC OVERRIDE OF EXECUTE STATEMENT
	IF (PRGNAM.EQ.BLANKS) PRGNAM=CHAIN
.ENDC

;*************************************************************
; CHECK MESARA FILE TO SEE WHICH SORT WILL BE USED
;*************************************************************
	CLOSE 13
	OPEN (13,U,'UT:MESARA.DDF')
.IFNDEF MCBSRT
	ON ERROR RDCTL
RDCTL,
	READ (13,MESARA,1)
	UNLOCK 13
	OFF ERROR
	GO TO (DIBSRT,MACSRT,RTSORT), SRTTYP + 1
	GO TO ERMSG4
.ENDC
.IFDEF MCBSRT
	GO TO DIBSRT
.ENDC

;*****************************************************************************

MACSRT,
	MCSORC = SOURCE
	MCDEST = SOURCE
  .IFDEF DEST
	MCDEST = DEST
  .ENDC
	MCCHAN = PRGNAM
.IFDEF MCTEMP
	MCTEMP(14,14) = 1		;DEFINE TEMPORARY WORK FILE WITH
					;SAME STANDARDS AS FOR MCBA SORT
					;SET THIRD CHARACTER OF COMPANY CODE
					;EQUAL TO 1
.ENDC
	CALL SQZMAC
	MSGSWT = 3			;CLEAR ONE MESSAGE
	XCALL SNMSG (BLANKS,MSGSWT)
	SEND (MACSRT(1,CNT2),'SY:SORT')
	STOP 'SY:SORT'

;*****************************************************************************

RTSORT,
.IFNDEF SYSTEM
	RTSORC = SOURCE
  .IFDEF DEST
	RTDEST = DEST
  .ENDC
.ENDC
	IF (RTDEST.EQ.RTSORC .OR. RTDEST.EQ.BLANKS) RTSORT (1,15) =
				;CLEAR OUTPUT FILESPEC SO THAT RTSORT 
				;DOES AN IN-PLACE SORT
	RTCHAN = PRGNAM
	CALL SQZRTS
	MSGSWT = 3			;CLEAR ONE MESSAGE
	XCALL SNMSG (BLANKS,MSGSWT)
	XCALL RTSRT (RTSORT(1,CNT2))
	STOP 'RTSORT.SAV'
;************************************************************************
DIBSRT,
	WRKEXT (1,2) = SOURCE (12,13)
	WRKDEV = 'SRT'			;DEFAULT WORK SPACE ASSIGNMENT
	J1=
LOOPA,
	INCR J1
	IF (J1.GT.6) GO TO ENDLUP
	IF (BUFF (J1,J1) .EQ.'.') GO TO LOOPB
	WRKNAM (J1,J1) = BUFF (J1,J1)
	GO TO LOOPA
LOOPB,
	WRKNAM (J1,J1) = WRKNAM (J1-1,J1-1)
	INCR J1
	IF (J1.LE.6) GO TO LOOPB

;****************************************************************
ENDLUP,
	FILNME=SOURCE
	CALL SQUEZF
	IF (RECCNT.EQ.0) RECCNT=MAXREC
	IF (RECCNT.NE.0) GO TO GO3
					;COUNT INPUT RECORDS
	OPEN (8,I,FILSPC)

;****************************************

COUNT,
	READS (8,SRTREC,GO2)
.IFDEF PAD
	IF (SRTREC.EQ.PAD) GO TO GO2	;DON'T COUNT DUMMY RECORDS
.ENDC
	INCR RECCNT
	GO TO COUNT
GO2,
	CLOSE 8
GO3,
	IF (ORGCNT.GE.RECCNT) GO TO ORG1	;NO SORTING IF ORGCNT = RECCNT
	SIZE= (RECCNT+1) * (RECLEN+2) /512+1	;SET DESTINATION FILE SIZE
	SIZE1=SIZE			;SET WORK FILE SIZE
.IFDEF KEYLEN
	SIZE1= (RECCNT+1) * (KEYLEN+7) /512+1	;WORKFILE SIZE FOR KEYSORT
.ENDC

;****************************************

					;CREATE WORK FILES
	WRKDEV='SRT'
	J1=1
	ONERROR ERMSG
X1,
	WRKEXT (3,3) =J1

.IFDEF DEVTBL
	WRKDEV=DEVTBL (J1)
.ENDC

	CALL SQUEZW
	OPEN (J1,O,FILSPW)
	INCR J1
	IF (J1.LE.P) GO TO X1

.IFDEF DEVTBL
	WRKDEV=DEVTBL (NWRK)
.ENDC

	WRKEXT (3,3) =NWRK

.IFNDEF MRGDST
  .IFDEF KEYLEN
	SIZE1=SIZE1+SIZE		;INSURE ENOUGH SPACE FOR KEYSORT
  .ENDC
.ENDC
	CALL SQUEZW

.IFNDEF SKPTST
	OPEN (NWRK,O,FILSPW)
	OFFERROR
	CLOSE NWRK
	XCALL DELET (NWRK,FILSPW)
.ENDC

.IFNDEF MRGDST
  .IFDEF KEYLEN
	SIZE1=SIZE1-SIZE		;RESET WORK FILE SIZE FOR KEYSORT
  .ENDC
.ENDC
	CALL SQUEZF
	OPEN (8,I,FILSPC)
					;BEGIN INTERNAL SORT PHASE
					; (SEE KNUTH,P.161 FOR EXPLANATION)
.IFDEF DETFLG
	DETACH
.ENDC

;****************************************

D1,	J=1
D1A,	A (J) =1
	DUMMY (J) =1
	INCR J
	IF (J.LE.P) GO TO D1A
	A (NWRK) =0
	DUMMY (NWRK) =0
	LL=1
	J=1
	IF (ORGCNT.LE.1) GO TO D2
	SWFL (1) =
	INREC = ORGCNT
	GO TO ORG4
ORG1,
	OPEN (8,I,FILSPC)
.IFDEF DEST				;IF NO  SORT, CREATE DESTINATION FILE
	FILNME=DEST
	CALL SQUEZF
	OPEN (9,O,FILSPC)
ORG2,
	INCR RECS
	READS (8,SRTREC,ORG3)
	WRITES (9,SRTREC)
	IF (RECS.LT.RECCNT) GO TO ORG2
ORG3,
	CLOSE 9
.ENDC
	CLOSE 8
	GO TO END2
ORG4,					;TRANSFER ALREADY SORTED RECORDS
					;TO FIRST WORK FILE.
	INCR RECS
	READS (8,SRTREC)
.IFNDEF KEYLEN
	WRITES (1,SRTREC)
.ENDC
.IFDEF KEYLEN
	CALL KPULL			;STRIP OFF KEYS AND ATTACH SEQNO
					;IF KEYSORT.
	SEQA=RECS
	WRITES (1,COMPA)
.ENDC
	IF (RECS.LT.ORGCNT) GO TO ORG4
.IFNDEF KEYLEN
	SAVREC=SRTREC
.ENDC
.IFDEF KEYLEN
	SAVREC=COMPA			;SAVE THE LAST RECORD IN THE
					;SORTED STRING.
	SEQNO=SEQA
.ENDC
	FSTFLG=				;TURN OFF FIRST BUFFER FLAG
D2,
	RECS=
D2A,
	INCR RECS
.IFNDEF KEYLEN
	READS (8,BUFF (RECS) ,ENDINP) 	;READ INTO INTERNAL BUFFER
.ENDC
.IFDEF KEYLEN				;IF KEYSORT, STRIP OFF KEYS
					;ADD SEQNO AND PUT IN BUFFER.
	INCR SEQNO
	READS (8,SRTREC,ENDINP)
	CALL KPULL
	SEQA=SEQNO
	BUFF (RECS) =COMPA
.ENDC
.IFDEF PAD
  .IFNDEF KEYLEN
	IF (BUFF (RECS) .EQ.PAD) GO TO ENDINP
					;DON'T PROCESS DUMMY RECORDS
  .ENDC
  .IFDEF KEYLEN
	IF (SRTREC.EQ.PAD) GO TO ENDINP
					;DON'T PROCESS DUMMY RECORDS
  .ENDC
.ENDC
	INCR INREC
	IF (RECS.EQ.RUNLEN) GO TO D2B
	GO TO D2A
.IFDEF KEYLEN
KPULL,					;SUBROUTINE TO STRIP OFF KEYS
	KEYA1=KEY1
  .IFDEF KEYA2
	KEYA2=KEY2
  .ENDC
  .IFDEF KEYA3
	KEYA3=KEY3
  .ENDC
  .IFDEF KEYA4
	KEYA4=KEY4
  .ENDC
  .IFDEF KEYA5
	KEYA5=KEY5
  .ENDC
  .IFDEF KEYA6
	KEYA6=KEY6
  .ENDC
  .IFDEF KEYA7
	KEYA7=KEY7
  .ENDC
	RETURN
.ENDC
ENDINP,
	RUNLEN=RECS-1			;RESET STRING LENGTH OF
					;LAST BUFFER LOAD.
	ENDFLG=1
	CLOSE 8
	IF (RECS.EQ.1) GO TO D2C		;LAST BUFFER HAS NO RECORDS
D2B,
					;SORT LOGIC FOLLOWS
					;SEE KNUTH, P.161
N1,
	S=0
N2,	IF (S.EQ.1) GO TO N2A
	I=1
	JJ=RUNLEN
	K=RUNLEN+1
	L=2*RUNLEN
	GO TO N2B
N2A,	I=RUNLEN+1
	JJ=2*RUNLEN
	K=1
	L=RUNLEN
N2B,	MOVPNT=1
	F=1
N3,
	COMPA=BUFF (I)
	COMPB=BUFF (JJ)
	CALL KEYCMP
	IF (LOKEY.EQ.2) GO TO N8
	IF (I.NE.JJ) GO TO N4
	BUFF (K) =BUFF (JJ)
	GO TO N13
N4,
	BUFF (K) =BUFF (I)
	K=K+MOVPNT
N5,
	INCR I
	COMPB=BUFF (I)
	CALL KEYCMP
	IF (LOKEY.EQ.1) GO TO N3
N6,
	BUFF (K) =BUFF (JJ)
	K=K+MOVPNT
N7,
	COMPA=BUFF (JJ)
	JJ=JJ-1
	COMPB=BUFF (JJ)
	CALL KEYCMP
	IF (LOKEY.EQ.1) GO TO N6
	GO TO N12
N8,
	BUFF (K) =BUFF (JJ)
	K=K+MOVPNT
N9,
	COMPA=BUFF (JJ)
	JJ=JJ-1
	COMPB=BUFF (JJ)
	CALL KEYCMP
	IF (LOKEY.EQ.1) GO TO N3
N10,
	BUFF (K) =BUFF (I)
	K=K+MOVPNT
N11,
	COMPA=BUFF (I)
	INCR I
	COMPB=BUFF (I)
	CALL KEYCMP
	IF (LOKEY.EQ.1) GO TO N10
N12,	F=0
	MOVPNT=-MOVPNT
	KK=K
	K=L
	L=KK
	GO TO N3
N13,	IF (F.NE.0) GO TO D2C		;SORT COMPLETE OF ONE BUFFER-LOAD
	S=1-S
	GO TO N2

;****************************************

				;DISTRIBUTE SORTED STRINGS TO WORK FILES
D2C,
	IF (RECS.EQ.1) GO TO D2J	;NO RECORDS IN STRING
	RECS=
	IF (S.EQ.0) RECS=RUNLEN		;WHICH HALF OF SPLIT BUFFER
					;AS THE SORTED STRING.
	ENDRUN=RECS+RUNLEN		;END OF STRING IN BUFFER
	IF (FSTFLG.NE.1) GO TO D2D
	FSTFLG=				;FIRST SORTED STRING
.IFNDEF KEYLEN
	IF (ENDFLG.EQ.0) GO TO D2G	;ONLY ONE STRING IN THIS SORT-PUT
					;IT IN THE DESTINATION FILE.
  .IFDEF DEST
	FILNME=DEST
	CALL SQUEZF
	OPEN (8,O,FILSPC)
  .ENDC
  .IFNDEF DEST
	OPEN (8,U,FILSPC)
  .ENDC
	RECCNT=
SNGBUF,
	INCR RECS
	INCR RECCNT
	IF (RECS.LE.ENDRUN) GO TO  SNGBF1
	CLOSE 8
	GO TO END2
SNGBF1,
	WRITE (8,BUFF (RECS) ,RECCNT)
	GO TO SNGBUF
.ENDC
.IFDEF KEYLEN
	GO TO D2G
.ENDC
D2D,
	COMPA=SAVREC
	COMPB=BUFF (RECS+1)
	CALL KEYCMP			;SHOULD LAST STRING BE CONTINUED?
	IF (LOKEY.EQ.2) GO TO D2F	;START NEW STRING
D2E,					;CONTINUE STRING ON CURRENT WORK FILE
	INCR RECS
	IF (RECS.GT.ENDRUN) GO TO D2I
	WRITES (J,BUFF (RECS))
	GO TO D2E
D2F,
	DUMMY (J) =DUMMY (J) -1		;DECREASE DUMMY STRING COUNT
	INCR RUNCNT (J) 		;INCREASE STRING COUNT
	WRITES (J,EOSREC) 		;WRITE END OF STRING MARK
	CALL NXTUNT			;GET NEXT WORK FILE FOR NEW STRING
	IF (SWFL (J) .NE.1) GO TO D2H
D2G,
	INCR RECS
	CALL WRT1
D2H,					;WRITE NEW STRING ON NEXT WORK FILE
	INCR RECS
	IF (RECS.GT.ENDRUN) GO TO D2I
	WRITES (J,BUFF (RECS))
	GO TO D2H
D2I,
	IF (ENDFLG.NE.0) GO TO D2J	;LAST STRING OF THE SORT
	SAVREC=BUFF (ENDRUN) 		;SAVE LAST RECORD OF CURRENT STRING
	GO TO D2

;****************************************

D2J,
	WRITES (J,EOSREC) 		;WRITE END OF STRING MARK AT
					;END OF LAST STRING
	DUMMY (J) =DUMMY (J) -1
	INCR RUNCNT (J)
				;MERGE PHASE--PROCEED WITH POLYPHASE MERGE
				;SEE KNUTH, P.270
	XZ=
D2K,				;TURN ON ALL BEGINNING I/O SWITCHES FOR
				;ALL WORK FILES
	INCR XZ
	SWFL (XZ) =1
	IF (XZ.LT.NWRK) GO TO D2K
	GO TO D5
NXTUNT,					;ROUTINE TO DETERMINE NEXT
					;WORKFILE FOR STRING DISTRIBUTION.
	IF (DUMMY (J) .GE.DUMMY (J+1)) GO TO D3
	INCR J
	RETURN
D3,	IF (DUMMY (J) .EQ.0) GO TO D4
	J=1
	RETURN
D4,	INCR LL
	AA=A (1)
	J=1
D4A,	DUMMY (J) =AA+A (J+1) -A (J)
	A (J) =AA+A (J+1)
	INCR J
	IF (J.LE.P) GO TO D4A
	J=1
	RETURN
D5,
.IFDEF MRGDST				;LAST LEVEL OF POLYPHASE MERGE-
					;MERGE TO DESTINATION FILE.
					;THIS SECTION IS COMPILED WHEN FINAL
					;MERGE IS TO DESTINATION FILE
					; (NON-KEY SORT OR OPTION 5) .
	IF (LL.EQ.1) GO TO D6B
.ENDC
	WRKEXT (3,3) =NWRK
.IFDEF DEVTBL
	WRKDEV=DEVTBL (NWRK)
.ENDC
	CALL SQUEZW
	OPEN (NWRK,O,FILSPW)
	MRGFLG=				;IF MERGE PHASE HAS ONLY ONE LEVEL,
					;DON'T OPEN LAST WORKFILE.
D5A,
	IF (LL.EQ.0) GO TO ENDSRT	;END OF MERGE PHASE
D5B,	IF (DUMMY (P) .EQ.0.AND.RUNCNT (P) .EQ.0) GO TO D6
					;PROCEED TO NEXT LEVEL OF POLYPHASE
					;MERGE.
	J=1				;DETERMINE WHICH STRINGS TO MERGE
	I=1
	CHANS=0
D5C,	IF (DUMMY (J) .NE.0) GO TO D5D
	INCR CHANS
	MRGCHN (I) =WRKCHN (J)
	INCR I
D5D,
	INCR J
	IF (J.LE.P) GO TO D5C
	IF (CHANS.NE.0) GO TO D5F
	INCR DUMMY (NWRK)
	J=1
D5E,	DUMMY (J) =DUMMY (J) -1
	INCR J
	IF (J.LE.P) GO TO D5E
	GO TO D5B
D5F,
	SEQNO=1
	IF (CHANS.GT.1) GO TO MLTMRG	;CHANS=1 IS JUST A TRANSFER FROM
					;ONE WORKFILE TO ANOTHER.
	LOUNIT=1			;TRANSFER THE STRING.
	XY=1
	IF (SWFL (MRGCHN (XY)) .EQ.0) GO TO ONE1
	CALL RD1
	GO TO ONE2
ONE1,
	READS (MRGCHN (1) ,BUFF (1))
ONE2,
	IF (SWFL (WRKCHN (NWRK)) .EQ.0) GO TO ONE3
	CALL WRT2
	GO TO ONE5
ONE3,
.IFNDEF PAD
	WRITES (WRKCHN (NWRK) ,BUFF (1))
.ENDC
.IFDEF PAD
	IF (LL.EQ.1) GO TO ONE4		;IF PAD IS USED, AND SOURCE = DEST,
					;THE LAST MERGE	IS TO THE SOURCE FILE
					;IN UPDATE MODE TO PRESERVE THE
					;DUMMY RECORDS.
	WRITES (WRKCHN (NWRK) ,BUFF (1))
	GO TO ONE5
ONE4,
	INCR SEQNO
  .IFDEF MRGDST
	IF (BUFF (1) .EQ.EOSREC) GO TO MRG11
  .ENDC
	WRITE (WRKCHN (NWRK) ,BUFF (1) ,SEQNO)
.ENDC
ONE5,
	IF (BUFF (1) .EQ.EOSREC) GO TO MRG11
	READS (MRGCHN (1) ,BUFF (1))
	GO TO ONE3
MLTMRG,					;MULTIPLE MERGE-TWO OR MORE
					;STRINGS ARE MERGED.
	XY=
MRG1,
	INCR XY
	IF (SWFL (MRGCHN (XY)) .EQ.0) GO TO MRG2
	CALL RD1
	GO TO MRG3
MRG2,
	READS (MRGCHN (XY) ,BUFF (XY))
MRG3,
	IF (XY.LT.CHANS) GO TO MRG1
MRG4,
	LOUNIT=1
	COMPA=BUFF (1)
	COMPB=BUFF (2)
	XZ=2
MRG5,
	CALL KEYCMP
	IF (LOKEY.EQ.1) GO TO MRG6
	LOUNIT=XZ
	COMPA=BUFF (XZ)
MRG6,
	IF (XZ.EQ.CHANS) GO TO MRG7
	INCR XZ
	COMPB=BUFF (XZ)
	GO TO MRG5
MRG7,
	IF (SWFL (WRKCHN (NWRK)) .EQ.0) GO TO MRG8
	CALL WRT2
	GO TO MRG10
MRG8,
.IFNDEF PAD				;IF PAD IS USED AND SOURCE = DEST,
					;THE LAST MERGE IS TO THE SOURCE
					;FILE IN UDPATE MODE TO PRESERVE THE
					;DUMMY RECORDS.
	WRITES (WRKCHN (NWRK) ,BUFF (LOUNIT))
.ENDC
.IFDEF PAD
	IF (LL.EQ.1) GO TO MRG9
	WRITES (WRKCHN (NWRK) ,BUFF (LOUNIT))
	GO TO MRG10
MRG9,
	INCR SEQNO
  .IFDEF MRGDST
	IF (BUFF (LOUNIT) .EQ.EOSREC) GO TO MRG11
  .ENDC
	WRITE (WRKCHN (NWRK) ,BUFF (LOUNIT) ,SEQNO)
.ENDC
MRG10,
	IF (BUFF (LOUNIT) .EQ.EOSREC) GO TO MRG11
						;THE END OF STRING MARKER
						;IS THE LOW RECORD.
	READS (MRGCHN (LOUNIT) ,BUFF (LOUNIT))
						;THE STRINGS ARE COMPLETELY
						;MERGED.
	GO TO MRG4
MRG11,
	J=1
MRG12,			;ADJUST STRING COUNTS AND DUMMY STRING COUNTS
	IF (DUMMY (J) .NE.0) GO TO MRG13
	RUNCNT (J) =RUNCNT (J) -1
	GO TO MRG14
MRG13,
	DUMMY (J) =DUMMY (J) -1
MRG14,
	INCR J
	IF (J.LE.P) GO TO MRG12
	INCR RUNCNT (NWRK)
	GO TO D5B

;****************************************

D6,				;INITIALIZE FOR NEXT LEVEL OF POLYPHASE MERGE
	LL=LL-1
	SWFL (WRKCHN (P)) =1
	SWFL (WRKCHN (NWRK)) =1
	J=0
	SWKCHN=WRKCHN (NWRK)
	SRNCNT=RUNCNT (NWRK)
	SDUMMY=DUMMY (NWRK)
D6A,	WRKCHN (NWRK-J) =WRKCHN (P-J)
	DUMMY (NWRK-J) =DUMMY (P-J)
	RUNCNT (NWRK-J) =RUNCNT (P-J)
	INCR J
	IF (J.LE. (P-1)) GO TO D6A
	WRKCHN (1) =SWKCHN
	DUMMY (1) =SDUMMY
	RUNCNT (1) =SRNCNT
.IFDEF MRGDST
	IF (LL.NE.1) GO TO D5A
D6B,
	IF (MRGFLG) GO TO D6C		;POLYPHASE MERGE HAS ONLY ONE LEVEL.
					;LAST WORKFILE NEVER OPENED.
	CLOSE WRKCHN (NWRK) 		;GET RID OF ONE WORKFILE SO ONLY TWO
					;FILES ARE OPEN (TO SAVE CORE) .
	WRKEXT (3,3) =WRKCHN (NWRK)
  .IFDEF DEVTBL
	WRKDEV=DEVTBL (WRKCHN (NWRK))
  .ENDC
	CALL SQUEZW
	XCALL DELET (10,FILSPW)
D6C,
	WRKCHN (NWRK) =8
  .IFDEF KEYLEN
	SIZE = SIZE1
  .ENDC
  .IFDEF DEST
	FILNME=DEST
  .ENDC
	CALL SQUEZF

  .IFDEF PAD
    .IFNDEF DEST
	OPEN (WRKCHN (NWRK) ,U,FILSPC) 	;IF SOURCE=DEST AND PAD IS USED,
					;LAST WRITE IS IN UPDATE MODE.

	ONERROR RDMSG
RDMSG,
	READ (13,MESARA,TERMNO) 	; RETREIVE MESSAGE SLOT FOR TERMINAL.
	OFFERROR

	RESTRT =			; SWITCH OFF RE-START CAPABILITY.

	WRITE (13,MESARA,TERMNO) 	; RE-WRITE THE MESSAGE SLOT.

	CLOSE 13
      .IFDEF SYSTEM
	XCALL OUTPT (2,25,0,' MERGE PHASE')
					; INDICATE THE MERGE PHASE HAS STARTED
					; *** NOTE ***
					; AFTER THIS PHASE HAS BEGUN,
					; IT IS NOT POSSIBLE TO RE-START THE
					; JOB STREAM WITH THE SORT. THE FILE
					; WILL HAVE BEEN PARTIALLY DESTROYED.
					;	 (CMW 22-DEC-80)
      .ENDC
    .ENDC
    .IFDEF DEST
	OPEN (WRKCHN (NWRK) ,O,FILSPC)
    .ENDC
  .ENDC
  .IFNDEF PAD
	OPEN (WRKCHN (NWRK) ,O,FILSPC)
  .ENDC
.ENDC
	GO TO D5A

;*************************************************************************
;   E N D - O F - S O R T   C L E A N - U P
;*************************************************************************

ENDSRT,

.IFDEF KEYLEN
  .IFNDEF MRGDST
					;USE SORTED FILE OF KEYS TO CREATE
					;DESTINATION FILE OR RESEQUENCE
					;SOURCE FILE.
	SIZE1=SIZE
	CLOSE WRKCHN (2) 		;DELETE 2 WORKFILES TO SAVE
					;CORE SPACE.
	CLOSE WRKCHN (3)
	WRKEXT (3,3) =WRKCHN (2)

    .IFDEF DEVTBL
	WRKDEV=DEVTBL (WRKCHN (2))
    .ENDC

	CALL SQUEZW
	XCALL DELET (10,FILSPW)
	WRKEXT (3,3) =WRKCHN (3)

    .IFDEF DEVTBL
	WRKDEV=DEVTBL (WRKCHN (3))
    .ENDC

	CALL SQUEZW
	XCALL DELET (10,FILSPW)

    .IFNDEF DEST			;CREATE DUPLICATE SOURCE FILE
					;TO USE IN RESEQUENCING SOURCE FILE.
	OPEN (8,I,FILSPC)
	WRKEXT (3,3) =9
	CALL SQUEZW
	OPEN (9,O,FILSPW)
LOOP1,
	READS (8,SRTREC,EOF2)

      .IFDEF PAD
	IF (SRTREC.EQ.PAD) GO TO EOF2
      .ENDC

	WRITES (9,SRTREC)
	GO TO LOOP1
EOF2,
	CLOSE 8
    .ENDC

    .IFDEF DEST
	WRTCHN=9
	RDCHN=8
    .ENDC

    .IFNDEF DEST
	WRTCHN=8
	RDCHN=9
    .ENDC
	FILNME=SOURCE
	CALL SQUEZF
	OPEN (8,U,FILSPC)

    .IFNDEF DEST
	CLOSE 9
	OPEN (9,U,FILSPW)
    .ENDC

    .IFDEF DEST
	FILNME=DEST
	CALL SQUEZF
	OPEN (9,O,FILSPC)
    .ENDC
					;CREATE NEW DESTINATION FILE OR .
					;RESEQUENCE SOURCE FILE
	RECS=1
	READ (WRKCHN (1) ,COMPA,1)
	READ (RDCHN,SRTREC,SEQA)
	WRITE (WRTCHN,SRTREC,1)
LOOP3,
	INCR RECS
	IF (RECS.GT.RECCNT) GO TO END1
	READS (WRKCHN (1) ,COMPA)

    .IFNDEF DEST
	IF (SEQA.EQ.RECS) GO TO LOOP3
    .ENDC
	READ (RDCHN,SRTREC,SEQA)

    .IFNDEF DEST
	WRITE (8,SRTREC,RECS)
    .ENDC

    .IFDEF DEST
	WRITES (9,SRTREC)
    .ENDC
	GO TO LOOP3

END1,
  .ENDC
.ENDC

.IFDEF MRGDST
	READ (WRKCHN (1) ,BUFF,INREC) 	;GET RID OF END OF STRING
					;MARKER FROM OUTPUT FILE.
	WRITE (WRKCHN (1) ,BUFF,INREC)
.ENDC

.IFNDEF KEYLEN
	CLOSE WRKCHN (1)
.ENDC

.IFDEF KEYLEN
	CLOSE 9
  .IFNDEF DEST
	XCALL DELET (9,FILSPW) 		;DELETE DUPLICATE SOURCE FILE.
  .ENDC

	CLOSE 8
.ENDC

END2,
	IF (PRGNAM.EQ.BLANKS) STOP
	XCALL OUTPT (2,1,1,'\')		;ERASE THE "SORT FILE" MESSAGE.
	XCALL OUTPT (24,1,0,'\')
	MSGSWT = 3
	XCALL SNMSG (BLANKS,MSGSWT)
	XCALL PGCHN (PRGNAM,1)

;*************************************************************************
; SQUEEZE ROUTINES - FOR FILES SPECIFICATIONS AND SORT MESSAGES
;*************************************************************************
SQUEZF,
	CNT1 =
	CNT2 =
	FILSPC =
SQZFLP,
	IF (CNT1.GE.21) RETURN
	INCR CNT1
	IF (FILBL(CNT1,CNT1).EQ.BLANK) GO TO SQZFLP
	INCR CNT2
	FILSPC (CNT2,CNT2) = FILBL (CNT1,CNT1)
	GO TO SQZFLP
SQUEZW,
	CNT1 =
	CNT2 =
	FILSPW =
SQZWLP,
	IF (CNT1.GE.21) RETURN
	INCR CNT1
	IF (WRKFIL(CNT1,CNT1).EQ.BLANK) GO TO SQZWLP
	INCR CNT2
	FILSPW (CNT2,CNT2) = WRKFIL (CNT1,CNT1)
	GO TO SQZWLP

;*****************************************************************************

SQZMAC,
	CNT1 =
	CNT2 =
	TMPSRT =
SQZMLP,
	IF (CNT1.GE.CTCNT) GO TO ENDMSQ
	INCR CNT1
	IF (MACSRT(CNT1,CNT1).EQ.BLANK) GO TO SQZMLP
	INCR CNT2
	TMPSRT (CNT2,CNT2) = MACSRT (CNT1,CNT1)
	GO TO SQZMLP
ENDMSQ,
	MACSRT = TMPSRT
	RETURN

;*****************************************************************************

SQZRTS,			;SQUEEZE SPACES OUT OF RTSORT MESSAGE
	CNT1 =
	CNT2 =
	TMPSRT =
SQZRLP,
	IF (CNT1.GE.RTCNT) GO TO ENDRSQ
	INCR CNT1
	IF (RTSORT(CNT1,CNT1).EQ.BLANK) GO TO SQZRLP
	INCR CNT2
	TMPSRT (CNT2,CNT2) = RTSORT (CNT1,CNT1)
	GO TO SQZRLP
ENDRSQ,
	RTSORT = TMPSRT
	RETURN

;*************************************************************************
;  E R R O R   M E S S A G E   R E P O R T I N G
;*************************************************************************

ERMSG,				;ERROR--OPEN SCREEN AND DISPLAY MESSAGE

	XCALL OUTPT (4,1,0,'?SORT-F-SORT WORK FILE ERROR.')
	XCALL OUTPT (5,1,0,'POSSIBLY NOT ENOUGH WORK SPACE.')
.IFDEF DEVTBL
	XCALL OUTPT (6,1,0,'CHECK THESE ASSIGNMENTS --> ')

	CMWCNT =
CMWLUP,
	INCR CMWCNT
	IF (CMWCNT.GT.NWRK) GOTO CMWOUT
	DISPLAY (15,DEVTBL (CMWCNT) ,' ')
	GOTO CMWLUP

CMWOUT,
	DISPLAY (15,13,10)
.ENDC

.IFNDEF DEVTBL
	XCALL OUTPT (6,1,0,'CHECK TO SEE IF YOU HAVE "SRT:" ASSIGNED.')
.ENDC
	DISPLAY (15,13,10)

	STOP
					;MERGE PHASE IS COMPLETE
ERMSG1,

	XCALL OUTPT (4,1,0,
&		 '?SORT-F-SOURCE FILE NOT FOUND IN DEVICE TABLE.')
	 XCALL OUTPT (5,1,0,
&		' CONSULT YOUR SECURITY SYSTEM DOCUMENTATION INSTRUCTIONS.')
	DISPLAY (15,13,10)
	STOP

ERMSG3,
	XCALL OUTPT (4,1,0,
&	 '?SORT-F-DESTINATION FILE NOT FOUND IN DEVICE TABLE')
	XCALL OUTPT (5,1,0,
&	 ' CONSULT YOUR SECURITY SYSTEM DOCUMENTATION INSTRUCTIONS.')
	DISPLAY (15,13,10)
	STOP
ERMSG4,
	XCALL OUTPT (4,1,0,
&	'?SORT-F-INCORRECT SORT METHOD DESIGNATED')
	XCALL OUTPT (5,1,0,
&	'CONSULT YOUR COMPANY FILE MAINTENANCE DOCUMENTATION INSTRUCTIONS.')
	DISPLAY (15,13,10)
	STOP
ERMSG5,
	XCALL OUTPT (4,1,0,
&	'?SORT-F-MESSAGE NOT RECEIVED FROM PREVIOUS PROGRAM')
	DISPLAY (15,13,10)
	STOP

;*************************************************************************
;  I N T E R N A L   S U B R O U T I N E S   S E C T I O N
;*************************************************************************
;
;	THE NEXT THREE SUBROUTINES DO A READ FROM OR WRITE TO THE
;	BEGINNING OF A WORK FILE TO RESET THE RECORD POINTER FOR
;	THAT FILE. READING OR WRITING THEN PROCEEDS SEQUENTIALLY
;	AFTER RETURN.
;
WRT1,
	WRITE (J,BUFF (RECS) ,1)
	SWFL (J) =
	RETURN
RD1,
	READ (MRGCHN (XY) ,BUFF (XY) ,1)
	SWFL (MRGCHN (XY)) =
	RETURN
WRT2,
	WRITE (WRKCHN (NWRK) ,BUFF (LOUNIT) ,1)
	SWFL (WRKCHN (NWRK)) =
	RETURN

;*************************************************************************

KEYCMP,					;SUBROUTINE TO COMPARE KEYS
	LOKEY=1

.IFNDEF DESC1
	IF (KEYA1.GT.KEYB1) GO TO RESET
.ENDC

.IFDEF DESC1
	IF (KEYA1.LT.KEYB1) GO TO RESET
.ENDC

.IFDEF KEYA2
	IF (KEYA1.NE.KEYB1) RETURN

  .IFNDEF DESC2
	IF (KEYA2.GT.KEYB2) GO TO RESET
  .ENDC

  .IFDEF DESC2
	IF (KEYA2.LT.KEYB2) GO TO RESET
  .ENDC
.ENDC

.IFDEF KEYA3
	IF (KEYA2.NE.KEYB2) RETURN

  .IFNDEF DESC3
	IF (KEYA3.GT.KEYB3) GO TO RESET
  .ENDC

  .IFDEF DESC3
	IF (KEYA3.LT.KEYB3) GO TO RESET
  .ENDC
.ENDC

.IFDEF KEYA4
	IF (KEYA3.NE.KEYB3) RETURN

  .IFNDEF DESC4
	IF (KEYA4.GT.KEYB4) GO TO RESET
  .ENDC

  .IFDEF DESC4
	IF (KEYA4.LT.KEYB4) GO TO RESET
  .ENDC
.ENDC

.IFDEF KEYA5
	IF (KEYA4.NE.KEYB4) RETURN

  .IFNDEF DESC5
	IF (KEYA5.GT.KEYB5) GO TO RESET
  .ENDC

  .IFDEF DESC5
	IF (KEYA5.LT.KEYB5) GO TO RESET
  .ENDC
.ENDC

.IFDEF KEYA6
	IF (KEYA5.NE.KEYB5) RETURN

  .IFNDEF DESC6
	IF (KEYA6.GT.KEYB6) GO TO RESET
  .ENDC

  .IFDEF DESC6
	IF (KEYA6.LT.KEYB6) GO TO RESET
  .ENDC
.ENDC

.IFDEF KEYA7
	IF (KEYA6.NE.KEYB6) RETURN

  .IFNDEF DESC7
	IF (KEYA7.GT.KEYB7) GO TO RESET
  .ENDC

  .IFDEF DESC7
	IF (KEYA7.LT.KEYB7) GO TO RESET
  .ENDC
.ENDC

	RETURN
RESET,
	LOKEY=2
	RETURN

;*************************************************************************
