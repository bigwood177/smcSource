SUBROUTINE SRCHQ; (CHANEL,REDREC,KEY,STPOS1,ENPOS1,BSEND,BSMID,SRCCTL,
;			RCNOST,RCNOEN,ARKEYS,ARRECS,ARMAX)
;	SRCHQ / UTL 
;
;
;		::PCPYUTL.DEF::
;*****************************************************************************
;		SECURITY SYSTEM UTILITIES AND SUBROUTINES 
;		DIBOL FOR RT-11
;		
;		RELEASED: JANUARY 1, 1985
;*****************************************************************************
;
;
;		PROPRIETARY RIGHTS NOTICE:  All rights reserved.  This
;		material contains the valuable properties and trade secrets
;		of MCBA, Glendale, California, USA embodying substantial
;		creative effort and confidential information and ideas, no
;		part of which may be used and/or disclosed without MCBA's
;		duly authorized license agreement and/or written permission.
;
;		COPYRIGHT NOTICE:  Copyright <C> 1978, 1981, 1982, 1983, 1984,
;		1985, MCBA, AN UNPUBLISHED WORK.  ALL RIGHTS RESERVED.
;
;
;		COMPILE & LINK PER INSTALLATION OR TECHNICAL NOTES.
;
;:
;
;		THIS IS A VERSION OF THE SUBROUTINE "SERCH"
;		WHICH TRIES TO OPTIMIZE SEARCHING BY STORING KEY VALUES
;		AND RELATIVE RECORD NUMBERS IN AN EXTERNAL IN-MEMORY ARRAY.
;
	CHANEL	,D	; CHANNEL ON WHICH FILE IS TO BE READ
	REDREC	,A	; PARAMETER IN WHICH FOUND RECORD IS PASSED BACK
	KEY	,A	; KEY YOU'RE LOOKING FOR
	STPOS1	,D	; STARTING POSITION OF KEY FIELD IN RECORD
	ENPOS1  ,D	; ENDING POSITION OF KEY FIELD IN RECORD
	BSEND	,D	; COUNT OF SORTED RECORDS IN FILE
	BSMID	,D	; MID POINT (RECORD READ)
	SRCCTL	,D	; SPECIAL INCOMING VALUES:
			;  NOT "2" = RECORDS USE ZEROES IN THE DELETE FIELD
			;      "2" =     "    "  ]]]DEL  "  "     "     "
			; POST EXECUTION VALUES (OUT-GOING):
			;	0 = RECORD FOUND
			;	1 = RECORD NOT FOUND
	RCNOST	,D	; START POSITION OF FIELD WHERE RECORD IS
			; FLAGGED FOR DELETION.
	RCNOEN	,D	; END POSITION OF FIELD WHERE RECORD IS
			; FLAGGED FOR DELETION.
	ARKEYS	,A	; ARRAY OF KEYS THAT CORRESPOND TO "FENCED OFF" AREAS
			; OF THE FILE.
	ARRECS	,D	; ARRAY OF RELATIVE RECORD NUMBERS CORRESPONDING TO
			; EACH OF THE ABOVE KEY VALUES.
	ARMAX	,D	; THE UPPER LIMIT OF THE ARRAY (ARRAY SIZE)

		;************************************************************
		; PLEASE NOTE:
		;	"ARKEYS", "ARRECS", AND "ARMAX" ARE DEFINED
		;	WITHIN YOUR MAIN PROGRAM AND PASSED ALONG THROUGH
		;	THE XCALL TO THIS ROUTINE.  THE ARRAY SIZE SHOULD BE
		;	EQUAL TO A POWER OF TWO PLUS ONE:
		;
		;	(2 to the "n") + 1 = array size
		;	  where "n" is greater than zero
		;
		;	ARRAY SIZE SHOULD BE A MINIMUM OF "3"
		;
		;	EXAMPLE:
		;		Array size of 9 (2 to the 3rd + 1)
		;
		;		Calling program has these defined in its'
		;		Data Division:
		;
		;			ARKEYS	,9A15
		;			ARRECS	,9D5
		;			ARMAX	,D1	,9
		;
		;		and the call looks like this:
		;
		;	XCALL SRCHQ (1,ITMIDX,KEY,1,15,BSEND,BSMID,SRCCTL,
		;		     16,20,ARKEYS,ARRECS,ARMAX)
		;
		;***********************************************************


RECORD
	BSHI	,D6	; HIGH VALUE FOR SEARCH
	BSLO	,D6	; LOW VALUE FOR SEARCH
	BSMKEY	,A50	; KEY OF RECORD READ
	DEFLAG	,D1	; DELETE FLAG (DEFLAG = 1 WHEN SEARCHING
			; FORWARD FOR NON-DELETED RECORD).
	HITPTR	,D3	; POINTS TO CURRENT "HIT" ON THE FILE.
	BLANKS	,A50	;
	FILTYP	,D1	; INDICATES TYPE OF "DELETE" CHECK TO BE PERFORMED.
	DELETD	,A6	; FIELD FOR HOLDING DELETE COMPARISON.
	FENCE	,D18	; VALUE TO "FENCE OFF" THE IN-MEMORY SEARCH.
PROC
	DEFLAG =
	FILTYP =
	IF (SRCCTL.EQ.2) FILTYP = 1
	DELETD = '000000'
	IF (FILTYP.EQ.1) DELETD = ']]]DEL'

	BSMKEY =
	SRCCTL =

	IF (ARKEYS(1).EQ.BLANKS .AND. ARKEYS(2).EQ.BLANKS) CALL SETARY
				;
	BSLO = 1		; INITIAL LOW BINARY SEARCH POINT
	BSHI = BSEND		;    "    HIGH   "     "      "
	HITPTR = 0
PLUS8,
	HITPTR = HITPTR + 8
	IF (HITPTR.GT.ARMAX) GO TO BACKUP
	IF (ARKEYS(HITPTR).LE.KEY) GO TO PLUS8
BACKUP,
	HITPTR = HITPTR - 8
PLUS1,
	INCR HITPTR
	IF (HITPTR.GT.ARMAX) GO TO SETBSV
	IF (ARKEYS(HITPTR).LT.KEY) GO TO PLUS1
SETBSV,
	IF (HITPTR.GT.1) BSLO = ARRECS(HITPTR-1)
	IF (HITPTR.LT.ARMAX) BSHI = ARRECS(HITPTR)

MIDPT,
	BSMID = (BSHI+BSLO)/2
	CALL READ
	IF (BSMKEY.EQ.KEY) GO TO DELCHK
	IF (BSMID.EQ.BSHI.OR.BSMID.EQ.BSLO) GO TO LASTRY
	IF (BSMKEY.GT.KEY) BSHI = BSMID
	IF (BSMKEY.LT.KEY) BSLO = BSMID
	GO TO MIDPT
LASTRY,
	INCR BSMID
	IF (BSMID.GT.BSEND) GO TO BSNOM
	CALL READ
	IF (BSMKEY.EQ.KEY) GO TO DELCHK
BSNOM,				; START OF SEQUENTIAL SEARCH OF OVERFLOW AREA
	DEFLAG =		; BEYOND SORTED RECORDS
	BSMID = BSEND
SEQSCH,
	INCR BSMID
	CALL READ
	IF (SRCCTL.EQ.1) RETURN		; RECORD NOT FOUND
SEQSC2,
	IF (BSMKEY.EQ.KEY.AND.REDREC(RCNOST,RCNOEN).NE.DELETD) GOTO CHKTYP
	IF (DEFLAG.AND.BSMKEY.GT.KEY) GOTO BSNOM
	GOTO SEQSCH
DELCHK,
	DEFLAG = 1
	IF (FILTYP.NE.1) GO TO SEQSC2
CHKTYP,
	IF (FILTYP.EQ.0) GO TO EXIT
GTFRST,
	BSMID = BSMID - 1
	CALL READ
	IF (BSMKEY.EQ.KEY) GO TO GTFRST
FORWRD,
	INCR BSMID
	CALL READ
	IF (BSMKEY.NE.KEY) GO TO BSNOM
	IF (REDREC(RCNOST,RCNOEN).EQ.DELETD) GO TO FORWRD
EXIT,
	RETURN			; RETURN TO CALLING PROGRAM

;*************************************************************************

SETARY,
	FENCE = (BSEND/(ARMAX+1)) + 1
	HITPTR = 0
SETNXT,
	INCR HITPTR
	IF(HITPTR.GT.ARMAX) RETURN
	BSMID = HITPTR * FENCE
	IF (BSMID.GT.BSEND) BSMID = BSEND
	CALL READ
	ARRECS (HITPTR) = BSMID
	ARKEYS (HITPTR) = BSMKEY
	GOTO SETNXT

;*************************************************************************

READ,
	ONERROR READ
	READ (CHANEL,REDREC,BSMID)
	OFFERROR
	UNLOCK CHANEL
	IF (REDREC.EQ.']]]]]]') SRCCTL = 1
				; EOF CONDITION
	BSMKEY(1,ENPOS1-STPOS1+1) = REDREC(STPOS1,ENPOS1)
				; CREATE KEY FROM RECORD READ
	RETURN

;*************************************************************************
END
