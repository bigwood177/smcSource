;  GSORT / UTL 
;
;
;		::PCPYUTL.DEF::
;*****************************************************************************
;		SECURITY SYSTEM UTILITIES AND SUBROUTINES 
;		DIBOL FOR RT-11
;		
;		RELEASED: JANUARY 1, 1985
;*****************************************************************************
;
;
;		PROPRIETARY RIGHTS NOTICE:  All rights reserved.  This
;		material contains the valuable properties and trade secrets
;		of MCBA, Glendale, California, USA embodying substantial
;		creative effort and confidential information and ideas, no
;		part of which may be used and/or disclosed without MCBA's
;		duly authorized license agreement and/or written permission.
;
;		COPYRIGHT NOTICE:  Copyright <C> 1978, 1981, 1982, 1983, 1984,
;		1985, MCBA, AN UNPUBLISHED WORK.  ALL RIGHTS RESERVED.
;
;
;		COMPILE & LINK PER INSTALLATION OR TECHNICAL NOTES.
;
;:
;
;
;*************************************************************************
;	I M P O R T A N T   N E W   F E A T U R E S
;*************************************************************************
;
;	The error message table has been expanded from 50 lines of
;	input control file text to a new maximum of 500.
;
;	Error messages encountered are now written to the terminal as
;	stream output instead of using cursor controls.  This was
;	necessary for "batch" operations and hard-copy terminal operation.
;
;	"EXECUTE" statements now default to device "DK:" unless a device
;	is found hard-coded in the sort control file.
;
;	"SECURITY" is a new statement for release 2.0 utilities. Allows
;	user to sort SECURE file (or any other file) even when SECURE is
;	protected.
;
;	"INPUT" and "OUTPUT" files default to device "SRT:" unless a device
;	is found hard-coded in the sort control file.
;
RECORD
	,A64,'THIS MATERIAL CONTAINS THE VALUABLE PROPERTIES AND TRADE SECRETS'
	,A62,'OF MCBA, EMBODYING CONFIDENTIAL INFORMATION AND IDEAS, NO PART'
	,A56,'OF WHICH MAY BE USED AND/OR DISCLOSED WITHOUT MCBAs DULY'
	,A55,'AUTHORIZED LICENSE AGREEMENT AND/OR WRITTEN PERMISSION.'
	,A61,'COPYRIGHT (C) MCBA, AN UNPUBLISHED WORK. ALL RIGHTS RESERVED.'

RECORD
	INFIL	,A14			;SORT CONTROL FILE
	OUTFIL	,A14		;GSORT OUTPUT FILE OF DATA DIVISION STATEMENTS
	HZTABD	,D2,09		;ASCII REPRESENTATION OF HORIZONTAL TAB
	HZTAB	,A1			;HORIZONTAL TAB CHARACTER
	QUOTD	,D2,39			;ASCII REPRESENTATION OF QUOTE MARK
	QUOTA	,A1			;QUOTE CHARACTER
RECORD
	INFLG	,D1			;INPUT: STATEMENT FLAG
	OUTFLG	,D1			;OUTPUT: STATEMENT FLAG
	RECFLG	,D1			;RECORD: STATEMENT FLAG
	INCFLG  ,D1			;INCLUDE DEF FILE FLAG
	KEYFLG	,D1			;KEYS: STATEMENT FLAG
	SPCFLG	,D1			;SPACE: STATEMENT FLAG
	ENDFLG	,D1			;END: STATEMENT FLAG
	WRKFLG	,D1			;WORK: STATEMENT FLAG
	EXEFLG	,D1			;EXECUTE: STATEMENT FLAG
	DETFLG	,D1			;DETACH: STATEMENT FLAG
	PADFLG	,D1			;PAD: STATEMENT FLAG
	OPTFLG	,D1			;OPTIONS: STATEMENT FLAG
	SYSFLG	,D1			;SYSTEM: STATEMENT FLAG
	SECFLG	,D1			;SECURITY: STATEMENT FLAG
	CWUFLG	,D1			;CWU: STATEMENT FLAG (CLIENT WRITE UP)
	IDVFLG	,D1			;INPUT FILE DEVICE FLAG
	IEXFLG	,D1			;INPUT FILE EXTENSION FLAG
	ODVFLG	,D1			;OUTPUT FILE DEVICE FLAG
	OEXFLG	,D1			;OUTPUT FILE EXTENSION FLAG
	EDVFLG	,D1			;EXECUTE: STATEMENT PROGRAM NAME
					;DEVICE FLAG
	EEXFLG	,D1			;EXECUTE: STATEMENT PROGRAM NAME
					;EXTENSION FLAG
	ITMFLG	,D1			;DATA ITEM FLAG
	KWFLG	,D1			;KEY WORD FLAG
	MAXFLG	,D1			;INPUT: STATEMENT COUNT FIELD FLAG
	NAMFLG	,D1			;DATA ITEM NAME FLAG
	MCHFLG	,D1			;KEY MATCH FLAG
	ERFLG	,D1			;ERROR FLAG (USED AT VERINP)
	SPERFG	,D1			;SPACE ERROR FLAG
	NKYOPT	,D1			;OPTION 1 FLAG
	KEYOPT	,D1			;OPTION 2 FLAG
	DBLOPT	,D1			;OPTION 3 FLAG
	SKSPOP	,D1			;OPTION 4 FLAG
	TAGOPT	,D1			;OPTION 5 FLAG
RECORD
	INLINE	,A120			;CONTROL FILE INPUT LINE
	INCFIL  ,A14			;RECORD DEFINITION FILE
	OUTLIN	,A120			;DATA DIVISION LINE TO BE OUTPUT
	WRKLIN	,A70			;COMPRESSED INPUT LINE
	ERMSG	,A40			;ERROR MESSAGE
RECORD  DEVICE
                       .INCLUDE 'DEF:DEV001.DEF'  ;THESE ADDED NOV/84 TO SERCH
                                                  ;DEVICE TABLE FOR THE DEVNUM
RECORD
        DPNTR   ,D3                               ;OF THE FILES TO BE SORTED
                                                  ;INSTEAD OF SORT SERCHING.


RECORD					;CONTAINS VARIOUS COUNTERS AND INDEXES
	RECS	,D3			;INPUT RECORD COUNTER
	X1	,D3			;WORK INDEX
	I	,D3			;WORK INDEX
	J	,D3			;WORK INDEX
	ITMCNT	,D3			;DATA ITEM COUNTER
	KEYCNT	,D3			;KEY COUNTER
	NERR	,D3			;ERROR COUNTER
	N	,D3			;WORK INDEX
	FLDCNT	,D3			;COUNTS NUMBER OF CHARACTERS
					;IN A FIELD
	RECCNT	,D5			;NUMBER OF RECORDS IN SORT INPUT FILE
	NWRK	,D2,04			;NUMBER OF WORK FILES
	NKEYS	,D2			;NUMBER OF KEYS
	NITEM	,D2			;NUMBER OF DATA ITEMS
	TSTWRD	,A2			;TEST FIELD FOR SORT CONTROL
					;STATEMENT WORD
	TSTCHR	,A1			;HIGH OR LOW ORDER CHARACTER IN
					;END-OF-STRING RECORD
	ERNO	,D2
	ERCNT	,D2			;INDEX TO ERTBL ARRAY
	PADCNT	,D2			;COUNTS NUMBER OF PAD CHARACTERS
	PADLIM	,D3			;HOW MANY MORE PAD CHARACTERS TO
					;FILL THE PAD RECORD
	PADLEN	,D2			;HOW MANY CHARACTERS IN THIS PART OF
					;THE PAD RECORD
	NDEV	,D2			;NUMBER OF DEVICES GIVEN ON
					;WORK: STATEMENT
	RECLEN	,D3			;LENGTH OF SORT RECORD
	DEVCNT	,D2			;INDEX FOR THE DEVICE TABLE
	RUNLEN	,D3			;INITIAL STRING LENGTH
	ENTLEN	,D3			;LENGTH OF RECORD INVOLVED IN SORT
					;(RECLEN OR (KEYLEN+5) FOR A KEYSORT)
	KEYLEN	,D3			;SUM OF LENGTHS OF ALL KEYS
	PADCHR	,A1			;CHARACTER USED TO PAD DUMMY RECORDS
	ERLIN	,D3			;INPUT LINE NUMBER CONTAINING ERROR
	ERLINA	,A3			;USED TO DISPLAY INPUT LINE NUMBER
						;ON SCREEN
	CNT	,D1			;TWO INDEXES USED IN CHECKING FOR
					;KEYS WITH SAME NAME
	TST	,D1
	NOPT	,D2			;NUMBER OF OPTIONS
	OPTION	,4D1			;WHICH OPTIONS SPECIFIED
RECORD
	ERTBL	,500D2			;CONTAINS ERROR NUMBER CORRESPONDING
					;TO AN INPUT LINE
	DEVTBL	,7A3			;DEVICE ASSIGNMENT TABLE
RECORD INLBL				;SORT INPUT FILE LABEL
	IDEV	,A3
		,A1,':'
	INAM	,A6
		,A1,'.'
	IEXT	,A3
RECORD OUTLBL				;SORT OUTPUT FILE LABEL
	ODEV	,A3
		,A1,':'
	ONAM	,A6
		,A1,'.'
	OEXT	,A3
RECORD EXELBL				;PROGRAM NAME ON EXECUTE STATEMENT
	EXEDEV	,A3
		,A1,':'
	EXENAM	,A6
		,A1,'.'
	EXEXT	,A3
RECORD
	KBYTES	,D2,12			;SPACE AS GIVEN ON SPACE: STATEMENT
	SPACE	,D5			;KBYTES CONVERTED TO NUMBER
					;OF CHARACTERS
	PNTER	,D1			;INDEX IN SZARAY
	SIZE	,D5			;ACTUAL SIZE OF SORT PROGRAM
	SZARAY	,2D5,06500,06600	;BASIC SIZE OF SORT FOR
					;NON-KEY-SORT AND KEY-SORT
	KBYTEA	,A2			;ALPHA FIELD CONTAINING KBYTES
	NWRKA	,A1			;ALPHA FIELD CONTAINING NWRK
	ABORT	,D1			;FLAG TO SUSPEND GSORT OUTPUT
	PROCNO	,D1,2			;VARIABLE TO SET I/O BUFFER SIZE
					;IN SORT PROGRAM
	BUFSIZ	,D4,2000		;MAIN SORT BUFFER SIZE
	DIFF	,D5			;DIFFERENCE BETWEEN SIZE AND SPACE
	TSTSIZ	,D5			;TRIAL SIZE IN DETERMINING PROCNO
	SQZNAM	,A14			;FILE -NAME TO BE SQUEEZED
					;FREE OF BLANKS
RECORD
	FLDNAM	,99A6			;DATA ITEM NAME
	FLDTYP	,99A1			;DATA ITEM TYPE
	FLDSIZ	,99D3			;DATA ITEM SIZE
	FLDKEY	,99D1			;WHICH KEY MATCHES THIS DATA ITEM
	FLDCOL	,99D3			;STARTING COLUMN FOR DATA ITEM
	AUXERR	,D2			;ADDITIONAL ERROR FLAG
	SEQ	,7D1			;SEQ(I) = 1 INDICATES DESCENDING KEY
	KEYNAM	,7A6
	KEYITM	,7D2			;WHICH DATA ITEM MATCHES THIS KEY
	KEYRAT	,D2			;RATIO OF RECLEN TO KEYLEN
	KEYSRT	,D1			;FLAG INDICATING KEYSORT
	RTCNT	,D3			;LENGTH OF RTSORT RECORD CREATED
	CTCNT	,D3			;LENGTH OF MACSRT RECORD CREATED

RECORD DATLIN				;THE NEXT 3 RECORDS ARE FORMATTED
					;OUTPUT LINES USED IN FORMAT SECTION
		,A6
	DATNAM	,A6
		,A1,','
	DATTYP	,A1
	DATLEN	,A3
		,A61
RECORD DTLIN
		,A6
	DTNAM	,A6
		,A1,','
	DTTYP	,A1
	DTLEN	,A3
	COMMA1	,A1,','
	INIVAL	,A99

RECORD DTLIN1
		,A6
	DTNAM1	,A6
		,A1,','
	DTCNT1	,A3
	DTTYP1	,A1
	DTLEN1	,A3
	COMMA	,A1,','
	INIVL1	,A90

RECORD RTSLIN
		,A12
		,A5,',A23,'
	RT1QOT	,A1
		,A16,'/ITYPE:DRA/SIZE:'
	RTSREC	,D3			;RECORD SIZE OF FILE TO BE SORTED
		,A4,'/KEY'
	RT2QOT  ,A1

RECORD RTKEY
		,A6
		,A5,'RTKEY'
	RTKNUM	,D1		;THE KEY NUMBER
		,A4,',A9,'
	RT3QOT	,A1		;QUOTE LITERAL
		,A1,':'
	RTDTYP	,A1		;DATA TYPE
	RTSTYP	,A1		;SORT TYPE (ASCENDING OR DESCENDING)
	RTCLMN	,D3		;STARTING COLUMN NUMBER OF KEY
		,A1,'.'
	RTKLEN	,D2		;KEY LENGTH
	RT4QOT	,A1		;QUOTE LITERAL

RECORD MCPAD
		,A12
		,A4,',A5,'
	MC5QOT	,A1
		,A4,'/PA:'
	MCPADC	,A1
	MC6QOT	,A1

RECORD CTSLIN
		,A12
		,A5,',A27,'
	MC1QOT	,A1
		,A7,'/AS:SRT'
		,A4,'/RE:'
	MCSREC	,D3
		,A3,'/KE'
	MC2QOT	,A1

RECORD MCKEY
		,A6
		,A5,'MCKEY'
	MCKNUM	,D1		;THE KEY NUMBER
		,A4,',A9,'
	MC3QOT	,A1		;QUOTE LITERAL
	MCDELM	,A1		;DELIMITER - EITHER ":" OR ","
	MCDTYP	,A1		;DATA TYPE ("A"LPHA OR "D"ECIMAL)
	MCSTYP	,A1		;SORT TYPE ("A"SCENDING OR "D"ESCENDING)
	MCCLMN	,D3		;STARTING COLUMN NUMBER OF KEY
		,A1,'.'
	MCKLEN	,D2		;KEY LENGTH
	MC4QOT	,A1		;QUOTE LITERAL

RECORD				;VARIOUS LITERALS USED IN FORMAT SECTION
	KEYLIT	,A5,'KEY  '
	PROCLT	,A5,'PROC '
	DESC	,A5,'DESC '
	DATA1	,A13,'RECORD SRTREC'
	DATA2	,A12,'RECORD COMPA'
	DATA3	,A12,'RECORD COMPB'
	DATA4	,A10,'RECORD PAD'
	DATA5	,A13,'RECORD EOSREC'

	RTDATA  ,A13,'RECORD RTSORT'
	RTDEST	,A16,'      RTDEST,A14'
	EQUALS	,A25,'            ,A7,'',SRT:T='''
	RTSORC	,A16,'      RTSORC,A14'
	RTCHN	,A25,'            ,A7,''/CHAIN:'''
	RTCHAN	,A16,'      RTCHAN,A14'

	MCDATA	,A13,'RECORD MACSRT'
	MCINP	,A21,'            ,A3,''IN='''
	MCSORC	,A16,'      MCDEST,A14'
	MCOUT	,A23,'            ,A5,''/OUT='''
	MCDEST	,A16,'      MCSORC,A14'
	MCCHN	,A22,'            ,A4,''/CH='''
	MCCHAN	,A16,'      MCCHAN,A14'
	MCTMP	,A22,'            ,A4,''/TE='''
	MCTEMP	,A16,'      MCTEMP,A14'
	MCEND	,A21,'            ,A3,''/EN'''

	DATAR	,A6,'RECORD'

RECORD				;ERROR MESSAGE ARRAY
	,A33,'UNRECOGNIZED STATEMENT           ';01
	,A33,'INVALID FIELD IN OUTPUT STATEMENT';02
	,A33,'MULTIPLE CONTROL STATEMENT       ';03
	,A33,'INSUFFICIENT SPACE               ';04
	,A33,'SORT KEY MATCH ERROR             ';05
	,A33,'TYPE DEFINITION ERROR            ';06
	,A33,'SIZE DEFINITION ERROR            ';07
	,A33,'INVALID PAD CHARACTER--BLANK     ';08
	,A33,'INVALID NUMBER OF SORT KEYS      ';09
	,A33,'DATA ITEM NAME ERROR             ';10
	,A33,'DEVICE LABEL ERROR               ';11
	,A33,'INVALID SPACE ALLOCATION         ';12
	,A33,'INVALID INPUT RECORD COUNT       ';13
	,A33,'INVALID FLD IN EXECUTE STATEMENT ';14
	,A33,'INPUT: STATEMENT MISSING         ';15
	,A33,'OUTPUT: STATEMENT MISSING        ';16
	,A33,'RECORD: STATEMENT MISSING        ';17
	,A33,'RECORD HAS NO DATA ITEMS         ';18
	,A33,'KEYS: STATEMENT MISSING          ';19
	,A33,'END: STATEMENT MISSING           ';20
	,A33,'INVALID FIELD IN INPUT STATEMENT ';21
	,A33,'MISSING COLON                    ';22
	,A33,'TOO MANY CONTROL RECORDS         ';23
	,A33,'INVALID OPTION                   ';24
	,A33,'TOO MANY OPTIONS                 ';25
	,A33,'OPTION 5 NOT ALLOWED IN THIS CASE';26
RECORD	,X
	ERARY	,26A33
PROC
	OPEN(15,O,'TT:')
	XCALL FLAGS (01001010)		;ENABLE RUBOUT AND LOWER CASE
	DISPLAY(15,'    INFILE = ')
	READS(15,INFIL)
	OPEN(1,I,INFIL)
	DISPLAY(15,   '    OUTFILE = ')
	READS(15,OUTFIL)
	OPEN(2,O,OUTFIL)
	CLOSE 2
	XCALL ASCII(HZTABD,HZTAB)	;CONVERT HORIZONTAL TAB AND QUOTE
	XCALL ASCII(QUOTD,QUOTA)
READ,
	OFFERROR
	IF(ENDFLG)GO TO VERIFY		;END: STATEMENT HAS BEEN ENCOUNTERED
	INLINE=
	IF(INCFLG.EQ.1)READS(3,INLINE,DEFDUN)
	IF(INLINE(1,2).EQ.';:')GO TO DEFDUN
	IF(INCFLG.NE.1)READS(1,INLINE,VERIFY)
	INCR RECS
	IF(RECS.GT.500)GO TO RDER4		; MAX LIMIT 
	CALL CMPRSS
	IF(WRKLIN(1,1).EQ.' ')GO TO READ	;IGNORE BLANK LINES
	IF(ITMFLG)GO TO ITMPRO			;PROCESS DATA ITEM STATEMENT
	IF(KWFLG.EQ.0)GO TO RDER2		;NO COLON, AND NOT A DATA ITEM
						;STATEMENT - ERROR
KWORDS,
	TSTWRD=WRKLIN(1,2)
	IF(TSTWRD.EQ.'IN')GO TO INPRO
	IF(TSTWRD.EQ.'OU')GO TO OUTPRO
	IF(TSTWRD.EQ.'RE')GO TO RECPRO
	IF(TSTWRD.EQ.'KE')GO TO KEYPRO
	IF(TSTWRD.EQ.'SP')GO TO SPCPRO
	IF(TSTWRD.EQ.'WO')GO TO WRKPRO
	IF(TSTWRD.EQ.'EX')GO TO EXEPRO
	IF(TSTWRD.EQ.'DE')GO TO DETPRO
	IF(TSTWRD.EQ.'PA')GO TO PADPRO
	IF(TSTWRD.EQ.'EN')GO TO ENDPRO
	IF(TSTWRD.EQ.'OP')GO TO OPTPRO
	IF (TSTWRD.EQ.'SE') GO TO SECPRO
	IF (TSTWRD.EQ.'SY') GO TO SYSPRO
	IF (TSTWRD.EQ.'CW') GO TO CWUPRO
RDER1,
	ERTBL(RECS)=01
	INCR NERR
	GO TO READ
RDER2,
	ERTBL(RECS)=22
	INCR NERR
	GO TO READ
RDER3,
	ERTBL(RECS)=03
	INCR NERR
	GO TO READ
RDER4,
	ERTBL(RECS)=23
	INCR NERR
	GO TO VERIFY
DEFDUN,
	INCFLG=
	CLOSE 3
	GO TO READ
;****************************************************************************

CMPRSS,			;REMOVES BLANKS AND HORIZONTAL TABS FROM INPUT LINE
	KWFLG=
	WRKLIN=
	I=
	J=
LOOP2,
	INCR J
LOOP1,
	INCR I
	IF(I.GT.120)RETURN
	IF(INLINE(I,I).EQ.' ')GO TO LOOP1
	IF(INLINE(I,I).EQ.HZTAB)GO TO LOOP1
	IF(INLINE(I,I).EQ.';')RETURN	;IGNORE COMMENTS
	WRKLIN(J,J)=INLINE(I,I)
	IF(INLINE(I,I).NE.':')GO TO LOOP2
	KWFLG=1
	GO TO LOOP2

;*****************************************************************************

SECPRO,					;PROCESS SECURITY: STATEMENT
	IF (SECFLG) GO TO SECER1
	IF (WRKLIN(3,9).NE.'CURITY:') GO TO SECER2
	SECFLG = 1
	GO TO READ
SECER1,
	ERTBL(RECS) = 03
	INCR NERR
	GO TO READ
SECER2,
	ERTBL(RECS) = 01
	INCR NERR
	GO TO READ
;*****************************************************************************

SYSPRO,					;PROCESS SYSTEM: STATEMENT
	IF (SYSFLG) GO TO SYSER1
	IF (WRKLIN(3,7).NE.'STEM:') GO TO SYSER2
	SYSFLG = 1
	GO TO READ
SYSER1,
	ERTBL(RECS) = 03
	INCR NERR
	GO TO READ
SYSER2,
	ERTBL(RECS) = 01
	INCR NERR
	GO TO READ
;*****************************************************************************

CWUPRO,					;PROCESS CWU:STATEMENT
	IF (CWUFLG) GO TO CWUER1
	IF (WRKLIN(3,4).NE.'U:') GO TO CWUER2
	CWUFLG = 1
	GO TO READ
CWUER1,
	ERTBL (RECS) = 03
	INCR NERR
	GO TO READ
CWUER2,
	ERTBL (RECS) = 01
	INCR NERR
	GO TO READ

;*****************************************************************************

INPRO,					;PROCESS INPUT: STATEMENT
	IF(INFLG)GO TO INER1
	IF(WRKLIN(3,6).NE.'PUT:')GO TO INER2
	I=6
	INFLG=1
	X1=7
	FLDCNT=
IN1,
	INCR I
	IF(WRKLIN(I,I).EQ.' ')GO TO IN2
	IF(WRKLIN(I,I).EQ.'(')GO TO IN3
	IF(WRKLIN(I,I).EQ.')')GO TO IN4
	IF(WRKLIN(I,I).EQ.':')GO TO IN5
	IF(WRKLIN(I,I).EQ.'.')GO TO IN6
	INCR FLDCNT
	GO TO IN1
IN2,
	IF(MAXFLG)GO TO READ
	IF(IEXFLG)GO TO IN7
	IF(FLDCNT.GT.6.OR.FLDCNT.LT.1)GO TO INER3
	INAM=WRKLIN(X1,I-1)
	GO TO READ
IN3,
	IF(MAXFLG)GO TO INER3
	MAXFLG=1
	IF(IEXFLG)GO TO IN7
	IF(FLDCNT.GT.6.OR.FLDCNT.LT.1)GO TO INER3
	INAM=WRKLIN(X1,I-1)
	FLDCNT=
	X1=I+1
	GO TO IN1
IN4,
	IF(MAXFLG.EQ.0)GO TO INER3
	ONERROR INER4
	RECCNT=WRKLIN(X1,X1+FLDCNT-1)
	GO TO READ
IN5,
	IF(IDVFLG)GO TO INER3
	IDVFLG=1
	IF(FLDCNT.GT.3)GO TO INER3
	FLDCNT=
	IDEV=WRKLIN(X1,I-1)
	X1=I+1
	GO TO IN1
IN6,
	IF(IEXFLG)GO TO INER3
	IEXFLG=1
	IF(FLDCNT.LT.1.OR.FLDCNT.GT.6)GO TO INER3
	INAM=WRKLIN(X1,I-1)
	FLDCNT=
	X1=I+1
	GO TO IN1
IN7,
	IF(FLDCNT.LT.1.OR.FLDCNT.GT.3)GO TO INER3
	IEXT=WRKLIN(X1,I-1)
	FLDCNT=
	X1=I+1
	IF(WRKLIN(I,I).EQ.' ')GO TO READ
	GO TO IN1
INER1,
	ERTBL(RECS)=03
	INCR NERR
	GO TO READ
INER2,
	ERTBL(RECS)=01
	INCR NERR
	GO TO READ
INER3,
	ERTBL(RECS)=21
	INCR NERR
	GO TO READ
INER4,
	ERTBL(RECS)=13
	INCR NERR
	GO TO READ

;*****************************************************************************

OUTPRO,					;PROCESS OUTPUT: STATEMENT
	IF(OUTFLG)GO TO OUTER1
	I=7
	X1=8
	IF(WRKLIN(3,7).NE.'TPUT:')GO TO OUTER2
	FLDCNT=
	OUTFLG=1
OUT1,
	INCR I
	IF(WRKLIN(I,I).EQ.' ')GO TO OUT2
	IF(WRKLIN(I,I).EQ.':')GO TO OUT3
	IF(WRKLIN(I,I).EQ.'.')GO TO OUT4
	INCR FLDCNT
	GO TO OUT1
OUT2,
	IF(OEXFLG)GO TO OUT5
	IF(FLDCNT.LT.1.OR.FLDCNT.GT.6)GO TO OUTER3
	ONAM=WRKLIN(X1,I-1)
	GO TO READ
OUT3,
	IF(ODVFLG)GO TO OUTER3
	ODVFLG=1
	IF(FLDCNT.GT.3)GO TO OUTER3
	ODEV=WRKLIN(X1,I-1)
	X1=I+1
	FLDCNT=
	GO TO OUT1
OUT4,
	IF(OEXFLG)GO TO OUTER3
	OEXFLG=1
	IF(FLDCNT.LT.1.OR.FLDCNT.GT.6)GO TO OUTER3
	ONAM=WRKLIN(X1,I-1)
	X1=I+1
	FLDCNT=
	GO TO OUT1
OUT5,
	IF(FLDCNT.LT.1.OR.FLDCNT.GT.3)GO TO OUTER3
	OEXT=WRKLIN(X1,I-1)
	GO TO READ
OUTER1,
	ERTBL(RECS)=03
	INCR NERR
	GO TO READ
OUTER2,
	ERTBL(RECS)=01
	INCR NERR
	GO TO READ
OUTER3,
	ERTBL(RECS)=02
	INCR NERR
	GO TO READ

;*****************************************************************************

WRKPRO,					;PROCESS WORK: STATEMENT
	IF(WRKFLG)GO TO WRKER1
	IF(WRKLIN(3,5).NE.'RK:')GO TO WRKER2
	WRKFLG=1
	I=6
	X1=7
	FLDCNT=
	NDEV=
WRK1,
	ONERROR WRK2			;CHECK IF NUMBER OF WORK FILES GIVEN
	I=7
	NWRK=WRKLIN(6,6)
	IF(NWRK.LT.3)NWRK=3
	IF(NWRK.GT.7)NWRK=7
WRK2,
	OFFERROR
	IF(NWRK.EQ.0)NWRK=4
WRK3,
	INCR I
	IF(WRKLIN(I,I).EQ.' ')GO TO WRK4
	IF(WRKLIN(I,I).EQ.',')GO TO WRK3
	IF(WRKLIN(I,I).EQ.':')GO TO WRK5
	INCR FLDCNT
	GO TO WRK3
WRK4,
	IF(NDEV.NE.0)GO TO WRK6
	GO TO READ
WRK5,
	IF(FLDCNT.NE.3)GO TO WRKER3
	INCR NDEV
	DEVTBL(NDEV)=WRKLIN(I-3,I-1)
	IF(NDEV.EQ.NWRK)GO TO READ
	FLDCNT=
	GO TO WRK3
WRK6,
	IF(NDEV.GE.NWRK)GO TO READ
	J=
	DEVCNT=NDEV
WRK7,
	INCR DEVCNT
	INCR J
	DEVTBL(DEVCNT)=DEVTBL(J)
	IF(DEVCNT.EQ.NWRK)GO TO READ
	IF(J.EQ.NDEV)J=
	GO TO WRK7
WRKER1,
	ERTBL(RECS)=03
	INCR NERR
	GO TO READ
WRKER2,
	ERTBL(RECS)=01
	INCR NERR
	GO TO READ
WRKER3,
	ERTBL(RECS)=11
	GO TO READ

;*****************************************************************************

RECPRO,					;PROCESS RECORD: STATEMENT
	IF(RECFLG)GO TO RECER1
	IF(WRKLIN(3,7).NE.'CORD:')GO TO RECER2
	IF(WRKLIN(8,14).EQ.'INCLUDE')CALL INCPRO
	RECFLG=1
	ITMFLG=1
	NITEM=
	RECLEN=
	GO TO READ
INCPRO,
	INCFLG=1
	INCFIL=WRKLIN(15,29)
	OPEN(3,I,INCFIL)
	RETURN	
RECER1,
	ERTBL(RECS)=03
	INCR NERR
	GO TO READ
RECER2,
	ERTBL(RECS)=01
	INCR NERR
	GO TO READ

;*****************************************************************************

ITMPRO,					;PROCESS DATA ITEM STATEMENT
	IF(KWFLG)GO TO ITEM7		;NO MORE DATA ITEMS
	FLDCNT=
	I=
	NAMFLG=1
	INCR NITEM			;Nth data item in data record
ITEM1,
	INCR I
	IF(WRKLIN(I,I).EQ.',')GO TO ITEM2
	IF(WRKLIN(I,I).EQ.' ')GO TO ITEM5
	INCR FLDCNT			;Total # of characters in field name
	GO TO ITEM1
ITEM2,
	NAMFLG=
	IF(FLDCNT.EQ.0)GO TO ITEM3	;No name for this field, just a filler
	IF(FLDCNT.GT.6)GO TO ITMER1	;Field name too long
	FLDNAM(NITEM)=WRKLIN(1,FLDCNT)	;Load the field name
	FLDCNT=
ITEM3,
	INCR I
	IF(WRKLIN(I,I).NE.'A'.AND.WRKLIN(I,I).NE.'D')GO TO ITMER2
	FLDTYP(NITEM)=WRKLIN(I,I)	;Load the field type
	J=I+1				;First digit in field length
ITEM4,
	INCR I
	IF(WRKLIN(I,I).EQ.' ')GO TO ITEM5
	INCR FLDCNT
	GO TO ITEM4
ITEM5,
	ONERROR ITMER3
	IF(NAMFLG)GO TO ITMER3
	FLDSIZ(NITEM)=WRKLIN(J,J+FLDCNT-1)	;Load size of field
	FLDCOL(NITEM)=RECLEN+1		;Starting column for this field
	RECLEN=RECLEN+FLDSIZ(NITEM)	;Calculate record length from 
					;beginning of record through 
					;this field

	IF(FLDTYP(NITEM).EQ.'A'.AND.FLDSIZ(NITEM).GT.512)GO TO ITMER3
	IF(FLDTYP(NITEM).EQ.'D'.AND.FLDSIZ(NITEM).GT.18)GO TO ITMER3
	GO TO READ
ITEM7,
	IF(NITEM.LT.1)GO TO ITMER4
	ITMFLG=
	GO TO KWORDS
ITMER1,
	ERTBL(RECS)=10
	INCR NERR
	GO TO READ
ITMER2,
	ERTBL(RECS)=06
	INCR NERR
	GO TO READ
ITMER3,
	ERTBL(RECS)=07
	INCR NERR
	GO TO READ
ITMER4,
	AUXERR=18
	GO TO KWORDS

;*****************************************************************************

KEYPRO,					;PROCESS KEYS: STATEMENT
	IF(KEYFLG)GO TO KEYER1
	IF(WRKLIN(3,5).NE.'YS:')GO TO KEYER2
	KEYFLG=1
	FLDCNT=
	I=5
	NKEYS=
	J=6
KEY1,
	INCR I
	IF(WRKLIN(I,I).EQ.','.OR.WRKLIN(I,I).EQ.' ')GO TO KEY2
	INCR FLDCNT
	GO TO KEY1
KEY2,
	INCR NKEYS
	IF(WRKLIN(I-1,I-1).NE.'-')GO TO KEY3
	SEQ(NKEYS)=1
	FLDCNT=FLDCNT-1
KEY3,
	IF(FLDCNT.LT.1.OR.FLDCNT.GT.6)GO TO KEYER3
	KEYNAM(NKEYS)=WRKLIN(J,J+FLDCNT-1)
	IF(WRKLIN(I,I).EQ.' ')GO TO KEY4
	J=I+1
	FLDCNT=
	GO TO KEY1
KEY4,
	IF(NKEYS.LT.1.OR.NKEYS.GT.7)GO TO KEYER4
	GO TO READ
KEYER1,
	ERTBL(RECS)=03
	INCR NERR
	GO TO READ
KEYER2,
	ERTBL(RECS)=01
	INCR NERR
	GO TO READ
KEYER3,
	ERTBL(RECS)=10
	INCR NERR
	GO TO READ
KEYER4,
	ERTBL(RECS)=09
	INCR NERR
	GO TO READ

;*****************************************************************************

EXEPRO,					;PROCESS EXECUTE: STATEMENT
	IF(EXEFLG)GO TO EXER1
	IF(WRKLIN(3,9).NE.'ECUTE:')GO TO EXER2
	EXEFLG=1
	FLDCNT=
	X1=9
	I=8
EXE1,
	INCR I
	IF(WRKLIN(I,I).EQ.' ')GO TO EXE4
	IF(WRKLIN(I,I).EQ.':')GO TO EXE2
	IF(WRKLIN(I,I).EQ.'.')GO TO EXE3
	INCR FLDCNT
	GO TO EXE1
EXE2,
	IF(EDVFLG)GO TO EXER3
	EDVFLG=1
	IF(FLDCNT.GT.3)GO TO EXER3
	EXEDEV=WRKLIN(X1,I-1)
	X1=I+1
	FLDCNT=
	GO TO EXE1
EXE3,
	IF(EEXFLG)GO TO EXER3
	EEXFLG=1
	IF(FLDCNT.LT.1.OR.FLDCNT.GT.6)GO TO EXER3
	EXENAM=WRKLIN(X1,I-1)
	X1=I+1
	FLDCNT=
	GO TO EXE1
EXE4,
	IF(EEXFLG)GO TO EXE5
	IF(FLDCNT.LT.1.OR.FLDCNT.GT.6)GO TO EXER3
	EXENAM=WRKLIN(X1,I-1)
	GO TO READ
EXE5,
	IF(FLDCNT.GT.3)GO TO EXER3
	EXEXT=WRKLIN(X1,I-1)
	GO TO READ
EXER1,
	ERTBL(RECS)=03
	INCR NERR
	GO TO READ
EXER2,
	ERTBL(RECS)=01
	INCR NERR
	GO TO READ
EXER3,
	ERTBL(RECS)=14
	INCR NERR
	GO TO READ

;*****************************************************************************

PADPRO,					;PROCESS PAD: STATEMENT
	IF(PADFLG)GO TO PADER1
	IF(WRKLIN(3,4).NE.'D:')GO TO PADER2
	PADFLG=1
	IF(WRKLIN(5,5).EQ.' ')GO TO PADER3
	PADCHR=WRKLIN(5,5)
	GO TO READ
PADER1,
	ERTBL(RECS)=03
	INCR NERR
	GO TO READ
PADER2,
	ERTBL(RECS)=01
	INCR NERR
	GO TO READ
PADER3,
	ERTBL(RECS)=08
	INCR NERR
	GO TO READ

;*****************************************************************************

SPCPRO,					;PROCESS SPACE: STATEMENT
	IF(SPCFLG)GO TO SPCER1
	IF(WRKLIN(3,6).NE.'ACE:')GO TO SPCER2
	SPCFLG=1
	ONERROR SPCER3
	KBYTES=WRKLIN(7,8)
	GO TO READ
SPCER1,
	ERTBL(RECS)=03
	INCR NERR
	GO TO READ
SPCER2,
	ERTBL(RECS)=01
	INCR NERR
	GO TO READ
SPCER3,
	ERTBL(RECS)=12
	INCR NERR
	GO TO READ

;*****************************************************************************

DETPRO,					;PROCESS DETACH: STATEMENT
	IF(DETFLG)GO TO DETER1
	IF(WRKLIN(3,7).NE.'TACH:')GO TO DETER2
	DETFLG=1
	GO TO READ
DETER1,
	ERTBL(RECS)=03
	INCR NERR
	GO TO READ
DETER2,
	ERTBL(RECS)=01
	INCR NERR
	GO TO READ

;*****************************************************************************

OPTPRO,					;PROCESS OPTIONS: STATEMENT
	IF(OPTFLG)GO TO OPTER1
	IF(WRKLIN(3,8).NE.'TIONS:')GO TO OPTER2
	OPTFLG=1
	ONERROR OPTER3
	X1=8
OPT1,
	INCR X1
	IF(WRKLIN(X1,X1).EQ.' ')GO TO READ
	IF(WRKLIN(X1,X1).EQ.',')GO TO OPT1
	IF(NOPT.EQ.5)GO TO OPTER4
	INCR NOPT
	OPTION(NOPT)=WRKLIN(X1,X1)
	GO TO OPT1
OPTER1,
	ERTBL(RECS)=03
	INCR NERR
	GO TO READ
OPTER2,
	ERTBL(RECS)=01
	INCR NERR
	GO TO READ
OPTER3,
	ERTBL(RECS)=24
	INCR NERR
	GO TO READ
OPTER4,
	ERTBL(RECS)=25
	INCR NERR
	GO TO READ

;*****************************************************************************

ENDPRO,					;PROCESS END: STATEMENT
	IF(WRKLIN(3,4).NE.'D:')GO TO ENDERR
	ENDFLG=1
	GO TO READ
ENDERR,
	ERTBL(RECS)=03
	INCR NERR
	GO TO READ

;*****************************************************************************

VERIFY,					;VERIFY INPUT DATA
	IF(NERR.EQ.0)GO TO VERINP
	ABORT=1
	DISPLAY (15,13,10,10)
LOOPA,					;DISPLAY ALL ERRORS SO FAR
	INCR ERCNT
LOOP11,
	INCR ERLIN
	ERNO=ERTBL(ERLIN)
	IF(ERNO.EQ.0)GO TO LOOP11
	ERMSG=ERARY(ERNO)
	INCR ERNO
	CALL DSPERR
	IF(ERCNT.EQ.NERR)GO TO CLEAR
	GO TO LOOPA
CLEAR,					;CLEAR THE ERROR TABLE
	N=
LOOPB,
	INCR N
	ERTBL(N)=00
	IF(N.LT.10)GO TO LOOPB
	ERFLG=1
	IF(AUXERR.EQ.0)GO TO VERINP
	ERMSG=ERARY(AUXERR)
	CALL DSPERR
VERINP,				;CHECK IF ALL NECESSARY STATEMENTS EXIST
	ERFLG=1
	ERCNT=
	IF(INFLG)GO TO GO1
	INCR ERCNT
	ERTBL(ERCNT)=15
GO1,
	IF(OUTFLG)GO TO GO2
	INCR ERCNT
	ERTBL(ERCNT)=16
GO2,
	IF(RECFLG)GO TO GO3
	INCR ERCNT
	ERTBL(ERCNT)=17
GO3,
	IF(KEYFLG)GO TO GO41
	INCR ERCNT
	ERTBL(ERCNT)=19
GO41,
	IF(ENDFLG)GO TO GO4
	INCR ERCNT
	ERTBL(ERCNT)=20
GO4,
	IF(ERCNT.EQ.0)GO TO GO5
	IF(ABORT.EQ.0)
&		DISPLAY(15,13,10,'**** ERROR MESSAGES FOLLOW ****',13,10)
	ABORT=1
	N=
LOOP3,
	INCR N
	ERNO=ERTBL(N)
	ERMSG=ERARY(ERNO)
	CALL DSPERR
	IF(N.LT.ERCNT)GO TO LOOP3
	ERCNT=
GO5,
	IF(ABORT)GO TO DSPSUS
	ERNO = 5
	IF(NKEYS.EQ.1)GO TO MTCH1
	CNT=1
	TST=1
LOOP4,					;CHECK FOR DUPLICATE KEY NAMES
	INCR CNT
	IF(KEYNAM(CNT).EQ.KEYNAM(TST))GO TO TRMERR
	IF(CNT.LT.NKEYS)GO TO LOOP4
	INCR TST
	IF(TST.EQ.NKEYS)GO TO MTCH1
	CNT=TST
	GO TO LOOP4
MTCH1,				;CHECK THAT EACH KEY MATCHES A DATA ITEM
	KEYCNT=
LOOP5,
	IF(KEYCNT.EQ.NKEYS)GO TO SETOPT
	INCR KEYCNT
	MCHFLG=
	ITMCNT=
LOOP51,
	INCR ITMCNT
	IF(KEYNAM(KEYCNT).NE.FLDNAM(ITMCNT))GO TO LOOP52
	FLDKEY(ITMCNT)=KEYCNT	;SAVE MATCHING KEY POSITION FOR THIS ITEM
	KEYITM(KEYCNT)=ITMCNT	;SAVE MATCHING ITEM POSITION FOR THIS KEY
	KEYLEN=KEYLEN+FLDSIZ(ITMCNT)	;TOTAL KEY LENGTH THROUGH THIS KEY
	GO TO LOOP5
LOOP52,
	IF(ITMCNT.LT.NITEM)GO TO LOOP51
TRMERR,
	ERMSG=ERARY(ERNO)
	ERFLG=1
	IF(ABORT.EQ.0)
&		DISPLAY(15,13,10,'**** ERROR MESSAGES FOLLOW ****',13,10)
	CALL DSPERR
	GO TO DSPSUS
SETOPT,
	N=
SETOP1,					;SET OPTION FLAGS
	INCR N
	IF(N.GT.NOPT)GO TO VEROPT
	IF(OPTION(N).EQ.1)NKYOPT=1
	IF(OPTION(N).EQ.2)KEYOPT=1
	IF(OPTION(N).EQ.3)DBLOPT=1
	IF(OPTION(N).EQ.4)SKSPOP=1
	IF (OPTION(N).EQ.5)TAGOPT=1
	GO TO SETOP1
VEROPT,
	IF (TAGOPT.NE.1.OR.INLBL.NE.OUTLBL) GO TO CALC
	ERNO = 26
	GO TO TRMERR
CALC,				;CALCULATE SORT BUFFER SIZE, STRING LENGTH
					;DETERMINE IF KEY-SORT
					;ADJUST PROGRAM SIZE TO FIT IN SPACE
	KEYRAT=RECLEN/KEYLEN
	ENTLEN=RECLEN
	IF(TAGOPT)GO TO CALC1
	IF(NKYOPT)GO TO SPCALC
	IF(KEYOPT)GO TO CALC1
	IF(RECLEN.LT.90.OR.KEYRAT.LT.3)GO TO SPCALC
CALC1,
	KEYSRT=1
	ENTLEN=KEYLEN+5
SPCALC,
	PNTER=KEYSRT+1
	SIZE=SZARAY(PNTER)
	IF(INLBL.NE.OUTLBL)SIZE=SIZE+14
	IF(EXEFLG)SIZE=SIZE+52
	IF(DETFLG)SIZE=SIZE+8
	IF(PADFLG)SIZE=SIZE+RECLEN
	IF(KEYSRT.EQ.0)GO TO SP1
	SIZE=SIZE+25+RECLEN+(4*KEYLEN)
	GO TO SP2
SP1,
	SIZE=SIZE+5*RECLEN
SP2,
	SIZE=SIZE+(1034*NWRK)-1
	SPACE=KBYTES*1024
SP3,
	IF(SIZE.LE.SPACE)GO TO SP7
	DIFF=SIZE-SPACE
	IF(DIFF.GT.200)GO TO SP4
	BUFSIZ=BUFSIZ-DIFF
	GO TO SP7
SP4,
	PROCNO=1
	SIZE=SIZE-(512*NWRK)
SP5,
	IF(SIZE.LE.SPACE)GO TO SP7
	SPERFG=1
	IF(NWRK.EQ.3)GO TO SP6
	NWRK=NWRK-1
	SIZE=SIZE-522
	GO TO SP5
SP6,
	SPACE=SPACE+1024
	INCR KBYTES
	GO TO SP5
SP7,
	IF(DBLOPT.EQ.0)GO TO SP9
	IF(PROCNO.EQ.1)GO TO SP11
	SIZE=SIZE+BUFSIZ-(512*NWRK)
	BUFSIZ=2*BUFSIZ
SP8,
	IF(SIZE.LT.SPACE)GO TO SP9
	BUFSIZ=BUFSIZ-100
	SIZE=SIZE-100
	GO TO SP8
SP9,					;GET MAXIMUM PROC
	IF(DBLOPT)SIZE=SIZE+(NWRK*512)
	PROCNO=7
SP10,
	PROCNO=PROCNO-1
	IF(PROCNO.EQ.1)GO TO SP11
	TSTSIZ=SIZE+(NWRK*512)*(PROCNO-2)
	IF(TSTSIZ.GE.SPACE)GO TO SP10
SP11,
	RUNLEN=BUFSIZ/(2*RECLEN)
	IF(KEYSRT)RUNLEN=BUFSIZ/(2*(KEYLEN+5))

;*****************************************************************************

		;THE COMMENTS FOLLOWING, CONTAINING ONE
		;OR TWO WORDS IN QUOTES, CORRESPOND
		;TO THE LINES OF THE DATA  DIVISION THAT
		;GSORT IS GENERATING.
		;NO ERRORS - CREATE THE DATA DIVISION

FORMAT,
	IF(SPERFG)GO TO SPCERR		; 'RECORD SRTREC'
	OUTLIN=DATA1
	OPEN(2,O,OUTFIL)
	CALL WRTLIN
	IF(KEYSRT)GO TO FORM1
	DATTYP='A'
	DATLEN=RECLEN,'XXX'
	OUTLIN=DATLIN
	CALL WRTLIN
	GO TO FORM2
FORM1,
	ITMCNT=
FORM11,					;INSERT DATA ITEMS OF RECORD SRTREC
	DATNAM=				;ONLY ITEMS THAT ARE KEYS HAVE NAMES
	INCR ITMCNT
	IF(FLDKEY(ITMCNT).EQ.0)GO TO FORM12
	KEYLIT(4,4)=FLDKEY(ITMCNT)
	DATNAM=KEYLIT
FORM12,
	DATTYP=FLDTYP(ITMCNT)
	DATLEN=FLDSIZ(ITMCNT),'XXX'
	OUTLIN=DATLIN
	CALL WRTLIN
	IF(ITMCNT.LT.NITEM)GO TO FORM11
FORM2,
	KEYLIT(4,4)='A'
	OUTLIN=DATA2			;'RECORD COMPA'
FORM21,
	CALL WRTLIN
	ITMCNT=
FORM3,
	DATNAM=		;INSERT DATA ITEMS OF RECORD COMPA AND RECORD COMPB
	IF(ITMCNT.EQ.NITEM)GO TO FORM4
	INCR ITMCNT
	IF(FLDKEY(ITMCNT).EQ.0)GO TO FORM31
	KEYLIT(5,5)=FLDKEY(ITMCNT)
	DATNAM=KEYLIT
	GO TO FORM32
FORM31,
	IF(KEYSRT)GO TO FORM3
FORM32,
	DATTYP=FLDTYP(ITMCNT)
	DATLEN=FLDSIZ(ITMCNT),'XXX'
	OUTLIN=DATLIN
	CALL WRTLIN
	GO TO FORM3
FORM4,
	IF(KEYSRT.NE.1)GO TO FORM41
	DATNAM='SEQA'
	IF(KEYLIT(4,4).EQ.'B')DATNAM='SEQB'
	DATTYP='D'
	DATLEN=5,'XXX'
	OUTLIN=DATLIN
	CALL WRTLIN
FORM41,
	IF(KEYLIT(4,4).EQ.'B')GO TO FORM5
	KEYLIT(4,4)='B'
	OUTLIN=DATA3			;'RECORD COMPB'
	GO TO FORM21
FORM5,
	IF(PADFLG.NE.1)GO TO FORM6
	OUTLIN=DATA4			;'RECORD PAD'
	CALL WRTLIN
	DTNAM=
	DTTYP='A'
	PADLIM=RECLEN
FORM51,
	INIVAL=			;BUILD PAD RECORD EQUAL IN LENGTH TO SRTREC
	PADCNT=
	PADLEN=50
	IF(PADLIM.LT.50)PADLEN=PADLIM
	INIVAL(1,1)=QUOTA
FORM52,
	INCR PADCNT
	INIVAL(PADCNT+1,PADCNT+1)=PADCHR
	IF(PADCNT.LT.PADLEN)GO TO FORM52
	DTLEN=PADCNT,'XXX'
	INIVAL(PADCNT+2,PADCNT+2)=QUOTA
	OUTLIN=DTLIN
	CALL WRTLIN
	IF(PADLEN.EQ.PADLIM)GO TO FORM6
	PADLIM=PADLIM-PADLEN
	GO TO FORM51
FORM6,
	OUTLIN=DATA5		;'RECORD EOSREC' - END-OF-STRING RECORD
	CALL WRTLIN
	DTNAM=
	ITMCNT=
FORM61,
	INIVAL=
	INIVAL(1,1)=QUOTA
	COMMA1=','
	IF(ITMCNT.EQ.NITEM)GO TO FORM7
	INCR ITMCNT
	IF(FLDKEY(ITMCNT).EQ.0)GO TO FORM65
	IF(FLDTYP(ITMCNT).EQ.'A')GO TO FORM62
	TSTCHR='/'		; '/' IS GREATER THAN ANY DECIMAL DIGIT 
	IF(SEQ(FLDKEY(ITMCNT)))TSTCHR=':'    
					; ':' IS LESS THAN ANY DECIMAL DIGIT
	GO TO FORM63
FORM62,
	TSTCHR=']'		; ']' IS GREATER THAN ANY ALPHA CHARACTER
	IF(SEQ(FLDKEY(ITMCNT)))TSTCHR=' '
				; ' ' IS .LE. ANY ALPHA CHARACTER
FORM63,
	N=1
FORM64,
	INCR N
	INIVAL(N,N)=TSTCHR
	IF(N.LE.FLDSIZ(ITMCNT))GO TO FORM64
	INCR N
	INIVAL(N,N)=QUOTA
	GO TO FORM66
FORM65,
	IF(KEYSRT)GO TO FORM61
	COMMA1=
	INIVAL(1,1)=
FORM66,
	DTTYP='A'
	DTLEN=FLDSIZ(ITMCNT),'XXX'
	OUTLIN=DTLIN
	CALL WRTLIN
	GO TO FORM61
	COMMA1=','
FORM7,
	IF(KEYSRT.NE.1)GO TO FORMRT
	DTTYP='D'
	DTLEN=5,'XXX'
	INIVAL=
	INIVAL(1,5)=99999
	OUTLIN=DTLIN
	CALL WRTLIN

;*****************************************************************************
;		SET UP MESSAGE LINES FOR NON-MCBA SORTS
;*****************************************************************************

FORMRT,			;SET UP MESSAGE LINE FOR RTSORT
	OUTLIN=RTDATA		;'RECORD RTSORT'
	CALL WRTLIN
	OUTLIN=RTDEST		;FIELD NAME 'RTDEST'
	CALL WRTLIN
	OUTLIN=EQUALS		;EQUALS SIGN
	CALL WRTLIN
	OUTLIN=RTSORC		;FIELD NAME 'RTSORC'
	CALL WRTLIN
	RT1QOT = QUOTA		;SINGLE QUOTE
	RTSREC = RECLEN		;LOAD RECORD LENGTH
	RT2QOT = QUOTA		;SINGLE QUOTE
	OUTLIN=RTSLIN		;FIELD NAME 'RTLINE'
	CALL WRTLIN
	I =
FRMRT1,
	INCR I
	IF (I.GT.NKEYS) GO TO FRMRT2
	RTKNUM = I
	RT3QOT = QUOTA
	RTDTYP = FLDTYP(KEYITM(I))	;Load data type for this key
	RTSTYP = 'A'			;Default to ascending sort
	IF (SEQ.EQ.1) RTSTYP = 'D'
	RTCLMN = FLDCOL(KEYITM(I))	;Load starting column for this key
	RTKLEN = FLDSIZ(KEYITM(I))	;Field length of this key
	RT4QOT = QUOTA			;Single quote
	OUTLIN = RTKEY			;Field name 'RTKEYn'
	CALL WRTLIN
	GO TO FRMRT1
FRMRT2,
	OUTLIN = RTCHN			;'/CHAIN:' literal
	CALL WRTLIN
	OUTLIN = RTCHAN			;Field name 'RTCHAN'
	CALL WRTLIN
	RTCNT = 79 + NKEYS*9		;Calculate maximum record size
					;created for SORT.MAN

FORMMC,			;FORMAT MESSAGE LINE FOR CTS-300 MACRO SORT
	CTCNT = 84 + NKEYS*9		;Calculate maximum record size
					;created for SORT.MAN
	OUTLIN=MCDATA			;'RECORD MACSRT'
	CALL WRTLIN
	OUTLIN=MCINP			;'INPUT=' LITERAL
	CALL WRTLIN
	OUTLIN=MCSORC			;FIELD NAME 'MCSORC'
	CALL WRTLIN
	OUTLIN=MCOUT			;'/OUTPUT=' LITERAL
	CALL WRTLIN
	OUTLIN=MCDEST			;FIELD NAME 'MCDEST'
	CALL WRTLIN
	OUTLIN=MCCHN			;'/CHAIN=' LITERAL
	CALL WRTLIN
	OUTLIN=MCCHAN			;FIELD NAME 'MCCHAN'
	CALL WRTLIN

;	IF (INLBL.NE.OUTLBL) GO TO FRMMC1	;INPUT FILE IS DIFFERENT 
;						;FROM OUTPUT FILE
;	OUTLIN=MCTMP			;'/TEMP=' LITERAL
;	CALL WRTLIN
;	OUTLIN=MCTEMP			;FIELD NAME 'MCTEMP'
;	CALL WRTLIN
;	CTCNT = CTCNT + 18
FRMMC1,
	IF (PADFLG.NE.1) GO TO FRMMC2	;PAD CHARACTER NOT SPECIFIED	
	MC5QOT = QUOTA
	MCPADC = PADCHR
	MC6QOT = QUOTA
	OUTLIN = MCPAD	
	CALL WRTLIN
	CTCNT = CTCNT + 5
FRMMC2,	
	MC1QOT = QUOTA			;SINGLE QUOTE
	MCSREC = RECLEN + 2		;LOAD RECORD LENGTH
	MC2QOT = QUOTA			;SINGLE QUOTE
	OUTLIN=CTSLIN			;FIELD NAME 'CTSLIN'
	CALL WRTLIN
	I =
FRMMC3,
	INCR I
	IF (I.GT.NKEYS) GO TO FRMMC4
	MCKNUM = I
	MC3QOT = QUOTA
	IF (I.EQ.1)
	THEN
		MCDELM = ':'
	ELSE
		MCDELM = ','
	MCDTYP = FLDTYP(KEYITM(I))	;Load data type for this key
	MCSTYP = 'A'			;Default to ascending sort
	IF (SEQ.EQ.1) MCSTYP = 'D'
	MCCLMN = FLDCOL(KEYITM(I))	;Load starting column for this key
	MCKLEN = FLDSIZ(KEYITM(I))	;Field length of this key
	MC4QOT = QUOTA			;Single quote
	OUTLIN = MCKEY			;Field name 'MCKEYn'
	CALL WRTLIN
	GO TO FRMMC3
FRMMC4,
	OUTLIN = MCEND			;'/END' literal
	CALL WRTLIN

;*****************************************************************************

	OUTLIN=DATAR			;'RECORD' (ALL REMAINING DATA 
					;DIVISION STATEMENTS)
	CALL WRTLIN
	DTNAM='MAXREC'			; 'MAXREC'
	DTTYP='D'
	DTLEN=5,'XXX'
	INIVAL(1,5)=RECCNT,'XXXXX'
	OUTLIN=DTLIN
	CALL WRTLIN
	DTNAM1='BUFF'			; 'BUFF'
	DTCNT1=(2*RUNLEN),'XXX'
	DTTYP1='A'
	DTLEN1=ENTLEN,'XXX'
	COMMA=
	OUTLIN=DTLIN1
	CALL WRTLIN
	COMMA=','
	DATNAM='SAVREC'			; 'SAVREC'
	DATTYP='A'
	DATLEN=ENTLEN,'XXX'
	OUTLIN=DATLIN
	CALL WRTLIN
	DTNAM='RECLEN'			; 'RECLEN'
	DTTYP='D'
	DTLEN=3,'XXX'
	INIVAL=
	INIVAL(1,3)=RECLEN,'XXX'
	OUTLIN=DTLIN
	CALL WRTLIN
	DTNAM='RUNLEN'			; 'RUNLEN'	(STRING LENGTH)
	INIVAL(1,3)=RUNLEN,'XXX'
	OUTLIN=DTLIN
	CALL WRTLIN
	DTNAM = 'RTCNT'			; 'RTCNT'
	DTTYP = 'D'	
	DTLEN = '003'
	INIVAL(1,3) = RTCNT,'XXX'
	OUTLIN = DTLIN
	CALL WRTLIN
	DTNAM = 'CTCNT'			;'CTCNT'
	DTTYP = 'D'
	DTLEN = '003'
	INIVAL(1,3) = CTCNT,'XXX'
	OUTLIN = DTLIN
	CALL WRTLIN
	IF(KEYSRT.NE.1)GO TO FORM80
	DTNAM='KEYLEN'			; 'KEYLEN'
	INIVAL(1,3)=ENTLEN,'XXX'
	OUTLIN=DTLIN
	CALL WRTLIN
FORM80,
	DTCNT1=NWRK,'XXX'
	INIVAL=
	INIVL1=
	IF(NDEV.EQ.0)GO TO FORM8C
	DTNAM1='DEVTBL'		; 'DEVTBL' (DOESN'T OCCUR IF ALL ON WRK:)
				; (ASSUMMED THAT NEW SORT.DBL IS USED)
	DTTYP1='A'
	DTLEN1=3,'XXX'
	N=
	X1=1
FORM8A,
	INCR N
	INIVL1(X1,X1)=QUOTA
	INIVL1(X1+1,X1+3)=DEVTBL(N)
	INIVL1(X1+4,X1+4)=QUOTA
	IF(N.EQ.NWRK)GO TO FORM8B
	INIVL1(X1+5,X1+5)=','
	X1=X1+6
	GO TO FORM8A
FORM8B,
	OUTLIN=DTLIN1
	CALL WRTLIN
FORM8C,
	COMMA=
	DTLEN1=3,'XXX'
	INIVL1=
	DTNAM1='A'			; 'A'  (USED IN POLYPHASE MERGE 
					; ALGORITHM--SEE SORT.MAN LISTING)
	DTTYP1='D'
	OUTLIN=DTLIN1
	CALL WRTLIN
	DTNAM1='DUMMY'			; 'DUMMY'
	OUTLIN=DTLIN1
	CALL WRTLIN
	DTNAM1='RUNCNT'			; 'RUNCNT'
	OUTLIN=DTLIN1
	CALL WRTLIN
	DTNAM1='MRGCHN'			; 'MRGCHN'
	DTLEN1=1,'XXX'
	DTCNT1=(NWRK-1),'XXX'
	OUTLIN=DTLIN1
	CALL WRTLIN
	DTNAM='NWRK'			; 'NWRK'
	DTTYP='D'
	DTLEN=1,'XXX'
	INIVAL(1,1)=NWRK
	OUTLIN=DTLIN
	CALL WRTLIN
	DTNAM='P'			; 'P' = (NWRK-1) (HIGHEST ORDER MERGE)
	INIVAL(1,1)=NWRK-1
	OUTLIN=DTLIN
	CALL WRTLIN
	DTNAM='SOURCE'			; 'SOURCE'
	DTTYP='A'
	DTLEN=14,'XXX'
	IF(IDVFLG)GO TO FORM81
	IDEV='SRT'
FORM81,
	IF(IEXFLG)GO TO FORM82
	IEXT='DDF'
FORM82,
	INIVAL(1,1)=QUOTA
;	SQZNAM = INLBL
;	CALL SQUEZE
	INIVAL (2,15) = INLBL		;NO SQUEEZE OF FILE-SQUEEZED IN SORT
	INIVAL(16,16)=QUOTA
	OUTLIN=DTLIN
	CALL WRTLIN
	IF(INLBL.EQ.'UT :SECURE.DDF')GOTO FORMEN
	CLOSE 13
        OPEN (13,I,'UT:DEVICE.DDF')
        DPNTR=
FNDSOR,
        INCR DPNTR
        IF (DPNTR.GT.200) GOTO ERMSG1
        ONERROR ERMSG2
RDDVSO,
        READ (13,DEVICE,DPNTR)
        OFFERROR
        IF (FILNAM.NE.INAM) GOTO FNDSOR
        DTNAM='DEVIN '
        DTTYP='D'
        DTLEN=3,'XXX'
        INIVAL=
        INIVAL(1,3)=DPNTR,'XXX'
        OUTLIN=DTLIN
        CALL WRTLIN

FORMEN,
	IF(ODVFLG)GO TO FORM83
	ODEV='SRT'
FORM83,
	IF(OEXFLG)GO TO FORM84
	OEXT='DDF'
FORM84,
	IF(INLBL.EQ.OUTLBL)GO TO FORM85
	DTNAM='DEST'		;'DEST' (ONLY OCCURS IF DIFFERENT FROM SOURCE)
;	SQZNAM = OUTLBL
;	CALL SQUEZE
	INIVAL (2,15) = OUTLBL
	OUTLIN=DTLIN
	CALL WRTLIN
FORM85,
	IF(KEYSRT.NE.1)GO TO FORM88
	INIVAL=
	DTTYP='D'
	DTLEN=1,'XXX'
	IF(INLBL.EQ.OUTLBL)GO TO FORM87
	DTNAM='WRTCHN'		; 'WRTCHN'  (THESE TWO ONLY USED IN KEYSORT)
	INIVAL(1,1)=8
	OUTLIN=DTLIN
	CALL WRTLIN
	DTNAM='RDCHN'			; 'RDCHN'
	INIVAL(1,1)=9
	OUTLIN=DTLIN
	CALL WRTLIN
	GO TO FORM88
FORM87,
	DTNAM='WRTCHN'
	INIVAL(1,1)=9
	OUTLIN=DTLIN
	CALL WRTLIN
	DTNAM='RDCHN'
	INIVAL(1,1)=8
	OUTLIN=DTLIN
	CALL WRTLIN
FORM88,
	IF(EXEFLG.NE.1)GO TO FORM91
	IF(EDVFLG)GO TO FORM89
	EXEDEV=' DK'			; CHANGED 4-FEB-81 CMW
FORM89,
	IF(EEXFLG)GO TO FORM90
	EXENAM(7,7) = ' '
FORM90,
	DTNAM='CHAIN'		; 'CHAIN' (ONLY IF EXECUTE:STATEMENT EXISTS)
	DTTYP='A'
	DTLEN=14,'XXX'
	INIVAL=
	INIVAL(1,1)=QUOTA
	INIVAL(16,16)=QUOTA
	SQZNAM = EXELBL
	CALL SQUEZE
	OUTLIN=DTLIN
	CALL WRTLIN
FORM91,
	IF(DETFLG.NE.1)GO TO FORM92
	DATNAM='DETFLG'		; 'DETFLG' (ONLY IF DETACH:STATEMENT EXISTS)
	DATLEN=1,'XXX'
	OUTLIN=DATLIN
	CALL WRTLIN
FORM92,
	N=
	DATTYP='D'
	DATLEN=1,'XXX'
FORM93,
	INCR N
	IF(SEQ(N).NE.1)GO TO FORM94
	DESC(5,5)=N			; 'DESC1', ...... ,'DESC7'  (ONLY 
					; IF THAT KEY IS DESCENDING)
	DATNAM=DESC
	OUTLIN=DATLIN
	CALL WRTLIN
FORM94,
	IF(N.LT.NKEYS)GO TO FORM93
	PROCLT(5,5)=PROCNO
	DATNAM=PROCLT			; 'PROCN'
	DATLEN=1,'XXX'
	OUTLIN=DATLIN
	CALL WRTLIN
	IF(SKSPOP.EQ.0)GO TO FORM95
	DATNAM='SKPTST'			; 'SKPTST'
	OUTLIN=DATLIN
	CALL WRTLIN
FORM95,
	IF (TAGOPT.EQ.0.AND.KEYSRT.EQ.1) GO TO FORM96
	DATNAM = 'MRGDST'		; 'MRGDST' - OPTION = 5, NON-KEY SORT
	OUTLIN = DATLIN
	CALL WRTLIN
FORM96,
	IF (SYSFLG.NE.1) GO TO FORM97
	DATNAM = 'SYSTEM'		; 'SYSTEM' - FLAG FOR ACCTING PACKAGES
	OUTLIN = DATLIN
	CALL WRTLIN
FORM97,
	IF (CWUFLG.NE.1) GO TO FORM98
	DATNAM = 'CWU'			; 'CWU' - FLAG FOR CLIENT WRITE-UP
	OUTLIN = DATLIN
	CALL WRTLIN
FORM98,
	IF (SECFLG.NE.1) GO TO FORM99
	DATNAM = 'SEC20'		; 'SEC20' - FLAG FOR ALLOWING SORT
					; OF SECURE FILE WHILE IT IS PROTECTED
	OUTLIN = DATLIN
	CALL WRTLIN
FORM99,
	WRITES (2,' ')
	IF (SECFLG.EQ.1) WRITES (2,'	.INCLUDE UT:SORT.UTL')
	IF (SECFLG.NE.1) WRITES (2,'	.INCLUDE UT:SORT.MAN')

	DISPLAY(2,13,10,';')		;NECESSARY. OTHERWISE EOF MARK 
					;WILL BE TAKEN AS
	CLOSE 1				;A DATA NAME BY THE COMPILER
	CLOSE 2
	STOP

;*****************************************************************************

DSPERR,					;DISPLAY ERROR MESSAGE
ERR1,
	IF(ERFLG)GO TO ERR2
	ERLINA=ERLIN
	DISPLAY(15,13,10,'LINE ',ERLINA,': ',ERMSG)
	ERMSG=
	RETURN
ERR2,
	DISPLAY(15,13,10,ERMSG)
	ERMSG=
	RETURN

;*****************************************************************************
;			FATAL ERROR MESSAGES

ERMSG1,
        DISPLAY(15,13,10,
&	  '?SORT-F-FILE TO BE SORTED NOT FOUND IN DEVICE TABLE.')
        DISPLAY(15,13,10,
&         'CONSULT SECURITY SYSTEM AND SORT DOCUMENTATION INSTRUCTIONS.')
        STOP
ERMSG2,
        DISPLAY(15,13,10,'DEVICE.DDF NOT FOUND ON UT:')
	STOP
DSPSUS,
	DISPLAY(15,13,10,'***** OUTPUT SUSPENDED *****')
	STOP

;*****************************************************************************

WRTLIN,
	WRITES(2,OUTLIN)
	OUTLIN=
	RETURN

;*****************************************************************************

SPCERR,
	DISPLAY(15,13,10,ERARY(4))
	NWRKA=NWRK
	KBYTEA=KBYTES
	DISPLAY(15,13,10,'TRY ',NWRKA,' WORKFILES -- SPACE = ', KBYTEA)
	GO TO DSPSUS

;*****************************************************************************

SQUEZE,				;SQUEEZE SPACES OUT OF CONTROL RECORD
	J = 2
	I =
SQZ1,
	INCR I
	IF(I.GT.14) RETURN
	IF (SQZNAM(I,I).EQ.' ') GO TO SQZ1
	INIVAL(J,J) = SQZNAM (I,I)
	INCR J
	GO TO SQZ1
END
