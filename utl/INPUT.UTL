SUBROUTINE INPUT ; (ROW,COL,INMAX,MIN,INTYPE,FCNTYP,ENTRY,INXCTL)
;
;  INPUT / UTL 
;
;
;:
;
;		STANDARD ROUTINE TO INPUT & EDIT
;		DATA FROM THE VIDEO TERMINAL
;
	ROW	,D	; SCREEN ROW
	COL	,D	; SCREEN COLUMN
	INMAX	,D	; MAXIMUM # OF CHARACTERS ALLOWED
	MIN	,D	; MINIMUM # OF CHARACTERS ALLOWED
	INTYPE	,A	; TYPE OF DATA INPUT (SEE BELOW) (max = 4)
	FCNTYP	,A	; TYPE OF FUNCTIONS ENABLED (SEE BELOW) (max = 6)
	ENTRY	,A	; FIELD DATA IS PASSED BACK IN (max = 50)
	INXCTL	,D	; CONTROLS POST EXECUTION BRANCH

		; ***** TYPE CODES *****
		;	"A " = alphanumeric
		;	"L " = alphanumeric upper and lower case
		;	"^L" = left justify alpha field
		;	"^R" = right justify alpha field (if numeric)
		;------------------------------------------------
		;	"D " = DATE, edited for valid day & month
		;	       & redisplayed in MM/DD/YY format.
		;		Passed back converted to YYMMDD.
		;	"DN" = DATE. Do not edit format. For MMDDYY or DDMMYY
		;		format in calling program.
		;	"#  " = NUMERIC, POSITIVE ONLY
		;	"#- " = NUMERIC, POSITIVE OR NEGATIVE
		;	"N  " = same as # but doesn't display default 0 value
		;	"^^X" = For Numeric Types, indicates the number of
		;		decimal places allowed and converted
		;	"^^^Y" = For Numeric Types, indicates if 0, display
		;		number masked without commas in thousands
		;		and if 1, display masked with commas
		;---------------------------------------------------
		;	"C " = accept RETURN or Enabled functions only.
		;		sets max to 0
		;	"Y " = YES/NO answers, accepts only "Y" or "N"
		;		(no default accepted)
		;	"YN" = YES/NO answers, default to "N" on CR
		;	"YY" = YES/NO answers, default to "Y" on CR
		;
		; ***** FUNCTION CODES *******
		; The respective keys are enabled when codes are passed
		;
		; 	"U" = Up Arrow (ESC A)
		;	"D" = Down Arrow (ESC B)
		;	"E" = END key (Backspace or CTRL/H)
		;	"T" = Tab key     user defined
		;	"1" = PF1 (ESC P) user defined
		;	"2" = PF2 (ESC Q) user defined
		;	"F" = "Force Entry" mode - Don't display initial value
		;		regardless of incoming contents of ENTRY
		;	 (PF3 RESERVED FOR "INSERT" MODE
		;	 (PF4 RESERVED FOR "ABORT"
		;
		;
		; ***** INXCTL RETURN CODES *****
		;	0 = INPUT OK, NO MESSAGE
		;	1 = ABORT key pressed + "SCREEN NOT PROCESSED" message
		; THE FOLLOWING ARE RETURNED ONLY WHEN ENABLED AS FUNCTION 
		; CODES:
		;	2 = "END" key (BACKSPACE or ^H)
		;	3 = TAB key
		;	4 = Up Arrow
		;	5 = Down Arrow
		;	6 = PF1 (ESC P)
		;	7 = PF2 (ESC Q)
		;
;*****************************************************************************
;			DATE FORMAT OPTION
;*****************************************************************************
;RECORD DATE	;This Record, when defined, formats date in DDMMYY format
;	DD	,D2
;	MM	,D2
;	YY	,D2
;RECORD,X
;	DDMMYY	,D6
			;As shipped, the MMDDYY date format is enabled. To
			;select DDMMYY date format, remove the semi-colons 
			;from the beginning of the six lines ABOVE (beginning 
			;with RECORD DATE and ending with 'DDMMYY') and insert
			;semi-colon in front of the six lines BELOW. ALSO,
			;make change to error message in BADDTE paragraph 
			;below.  Make a similar changes in the DSPLY.UTL 
			;subroutine to complete the process.
			;
RECORD DATE	;This Record, when defined, formats date in MMDDYY format
	MM	,D2
	DD	,D2
	YY	,D2
RECORD,X
	MMDDYY	,D6

RECORD OUTDTE
	Y	,D2
	M	,D2
	D	,D2
RECORD,X
	YYMMDD	,D6
COMMON      			;COMMON SYSTEM FIELDS SET IN TERID
			.INCLUDE 'DEF:COM001.DEF'
RECORD DOTS
		,A50,	'..................................................'
RECORD FCNFLG			;SPECIAL FUNCTION FLAGS (1 = ENABLED)
	UPAFLG	,D1		;UP ARROW
	DNAFLG	,D1		;DOWN ARROW
	ENDFLG	,D1		;END KEY
	TABFLG	,D1		;TAB KEY
	PF1FLG	,D1		;PF1 KEY
	PF2FLG	,D1		;PF2 KEY
	FRCFLG	,D1		;FORCE ENTRY AND DON'T DISPLAY DEFAULT
;
RECORD FCNARY			;FUNCTION ARRAY USED FOR SETTING UP FLAGS
	FCNSUB	,7A1
RECORD SAVTYP				;BREAKDOWN OF INTYPE FIELD
	TYPE	,A1
	MODE	,A1
	NUMDEC	,D1			;NUMBER OF DECIMAL PLACES FOR NUMBERS
	COMMA	,D1			;0 if don't mask with commas, 1 = mask
					;with commas.
RECORD MESAG
	MESSGE	,A50
		,A17
		,A12,	'PRESS RETURN'
RECORD			; WORK FIELDS
	BLANKS	,A50
	CHAR	,D2			;LOGS RELATIVE POSITION OF CURSOR
	COL2	,D2			;DISPLAY COLUMN FOR CURSOR POSTIONING
;
	COMMAS	,A28,	'ZZZ,ZZZ,ZZZ,ZZZ,ZZZ,ZZZ,ZZZ-'
;
	COUNT	,D2			;COUNTS # OF CHARACTERS IN FIELD
	DATMSK	,A8,	'XX/XX/XX'
	DAYS	,12D2,	31,28,31,30,31,30,31,31,30,31,30,31
	DECMAL	,D18
	INMASK	,A28			;MASK FIELD FOR NUMBERS ON INPUT DISPLAY
	MAX	,D2
	MAXFLG	,D1
	MONTH	,D2
	MSKNEG	,A28,	'XXXXXXXXXXXXXXXXXXXXXXXXXXX-'
	NEG	,D1
	NEGFLG	,D1
	OUTMSK	,A28
	SAVCNT	,D2
	SAVENT	,A50
	SAVSUB	,D2
	SAVMAX	,D2
	SV2ENT	,A50
	SPACES	,D1
	SUB	,D2			;WORKING STORAGE COUNTER
	DCHAR	,D3
	TCHAR	,D3
	WENTRY	,A50			;WORKING STORAGE FOR ENTRY
	XS	,A28,	'XXXXXXXXXXXXXXXXXXXXXXXXXXXX'
	YEAR	,D2
	ZEES	,A28,	'ZZZZZZZZZZZZZZZZZZZZZZZZZZZ-'
	stat	,d1
PROC
	SAVTYP = INTYPE
	NUMDEC = NUMDEC
	COMMA = COMMA
	SAVENT =
	SAVCNT =
	IF (TYPE.EQ.'L') XCALL FLAGS (10,1)
	FCNARY = FCNTYP
	FCNFLG =
	SUB =
;********************* Setup Function Flags ****************************
FCNLUP,
	IF (SUB.GE.7) GO TO RESET
	INCR SUB
	IF (FCNSUB(SUB).EQ.BLANKS) GO TO RESET
	IF (FCNSUB(SUB).EQ.'U') UPAFLG = 1
	IF (FCNSUB(SUB).EQ.'D') DNAFLG = 1
	IF (FCNSUB(SUB).EQ.'E') ENDFLG = 1
	IF (FCNSUB(SUB).EQ.'T') TABFLG = 1
	IF (FCNSUB(SUB).EQ.'1') PF1FLG = 1
	IF (FCNSUB(SUB).EQ.'2') PF2FLG = 1
	IF (FCNSUB(SUB).EQ.'F') FRCFLG = 1
	GO TO FCNLUP
;SETLED,
;	XCALL OUTPT (0,0,-1,'LEDOFF')
;	IF (PF1FLG) XCALL OUTPT (0,0,-1,'LED1')
;	IF (PF2FLG) XCALL OUTPT (0,0,-1,'LED2')
;	GO TO RESET
;********************** Setup Defaults and character counts *********
SETCM,			; NO MINIMUM OR MAXIMUM FOR 'C' CR TYPE
	INMAX =
	MAX =
	MIN =
	RETURN
CLRLIN,					;CLEAR ALL FIELDS AND START ANEW
	ENTRY =
	COUNT =
	CALL SETMAX
	IF (TYPE.EQ.'C') CALL SETCM
	IF (TYPE.EQ.'C') GO TO TYPEC
	WENTRY = DOTS
	XCALL OUTPT (ROW,COL,0,WENTRY(1,MAX))
	GO TO SPACES
RESET,					;SET/RESET INITIAL DISPLAY
	CALL SETMAX
	IF (TYPE.EQ.'C') CALL SETCM
	IF (TYPE.EQ.'C') GO TO TYPEC
	CALL SETDEF
	IF (FRCFLG) GO TO CLRLIN
	XCALL OUTPT (ROW,COL,0,WENTRY(1,MAX))
	SAVENT = ENTRY
	SAVCNT = COUNT
SPACES,
	SPACES = 1
	IF (COMMA) SPACES = (MAX-(NUMDEC+1))/3 + SPACES
					;CLEAR EXTRA SPACES AFTER PROMPTS
	IF (TYPE.EQ.'D') SPACES = 2
	XCALL OUTPT (0,0,0,BLANKS(1,SPACES))
TYPEC,
	CHAR = 1
	INXCTL =
	GO TO INPUT
SETMAX,
	NEGFLG =
	MAX = INMAX
	IF (MODE.EQ.'-') INCR MAX
	IF (NUMDEC) INCR MAX
	IF (TYPE.EQ.'C') MAX =
	RETURN
SETDEF,						;SETUP DEFAULT DISPLAY
	WENTRY = DOTS
	IF (TYPE.EQ.'#' .OR. TYPE.EQ.'N' .OR. TYPE.EQ.'D') CALL FORMAT
	IF (TYPE.NE.'#' .AND. TYPE.NE.'N') CALL SETMIN
	RETURN
FORMAT,
	ON ERROR BADDEF
	DECMAL = ENTRY
	GO TO DECOK
BADDEF,
	ENTRY =
	DECMAL =
DECOK,
	OFF ERROR
	IF (DECMAL.LT.0) NEGFLG = 1
	IF (TYPE.NE.'D') CALL SETMSK
	IF (TYPE.EQ.'D') CALL DATMSK
	WENTRY = DECMAL, INMASK
	SUB = 29			;MAX DECIMAL PLACES MASKED IS 20
						;SO NUMBER CAN'T START EARLIER
						;THAN 30
FRMLUP,						;LEFT JUSTIFY NUMBER IN FIELD
	IF (SUB.GE.50) GO TO OFSCAN
	INCR SUB
	IF (WENTRY(SUB,SUB).EQ.BLANKS) GO TO FRMLUP
OFSCAN,						;LOAD WENTRY WITH INITIAL
						;VALUE AND PROMPTS
	WENTRY (1,51-SUB) = WENTRY (SUB,50)
	WENTRY (52-SUB,50) =
	ENTRY = WENTRY				;LOAD ENTRY AS WELL IN ORDER
						;TO KEEP TRACK OF CHARACTER
						;COUNTS
	WENTRY (52-SUB,50) = DOTS
	COUNT = 51 - SUB
	IF (NEGFLG.EQ.0) WENTRY (51-SUB,51-SUB) = DOTS
	IF (NEGFLG.EQ.0) COUNT = 50 - SUB
	RETURN
SETMSK,						;SETUP INITIAL DISPLAY MASK
	INMASK = ZEES
	IF (NUMDEC.EQ.0) GO TO SETCMA
	INMASK (27-NUMDEC,27-NUMDEC) = DOTS
SETCMA,						;SETUP REDISPLAY MASK
	OUTMSK = INMASK
	IF (TYPE.EQ.'#' .AND. NUMDEC) OUTMSK (28-NUMDEC,27) = XS
	IF (TYPE.EQ.'#' .AND. NUMDEC.EQ.0) OUTMSK (27,27) = XS
	IF (COMMA.EQ.0) RETURN
	OUTMSK = COMMAS
	IF (NUMDEC.EQ.0) RETURN
	OUTMSK (1,26-NUMDEC) = OUTMSK (NUMDEC+2,27)
	IF (OUTMSK(1,1).EQ.',') OUTMSK (1,1) =
	OUTMSK (27-NUMDEC,27) = XS
	OUTMSK (27-NUMDEC,27-NUMDEC) = DOTS
	RETURN
DATMSK,
	INMASK = ZEES
	INMASK (27,28) = 'X '
	OUTMSK = DATMSK
	IF (MODE.EQ.'N') RETURN			;Do not convert if "N".

	DECMAL = ENTRY
	YYMMDD = DECMAL				;CONVERT INCOMING DATE
	MM = M					;FROM YYMMDD FORMAT
	DD = D					;TO MMDDYY
	YY = Y
	DECMAL = MMDDYY
	RETURN
SETMIN,						;SETUP CHARACTER COUNTER AND
						;LOAD ENTRY WITH INITIAL VALUE
	SUB = MAX + 1				
	IF (TYPE.EQ.'Y' .AND. (ENTRY.NE.'Y'.AND.ENTRY.NE.'N')) ENTRY =
	IF (TYPE.EQ.'Y' .AND. (MODE.NE.BLANKS.AND.MIN.EQ.0)) ENTRY (1,1) = MODE		
						;LOAD YES/NO WITH DEFAULT
MINLUP,
	SUB = SUB - 1
	IF (SUB.LT.1) GO TO SUBDUN
	IF (ENTRY(SUB,SUB).EQ.BLANKS) GO TO MINLUP
SUBDUN,
	IF (SUB.GT.0) WENTRY (1,SUB) = ENTRY (1,SUB)
	COUNT = SUB
	RETURN
;**************** Main Input logic ****************************
INPUT,
	COL2 = COL + CHAR - 1
	XCALL OUTPT (ROW,COL2,0,'\')
INPUT2,
	IF (SYSTM.EQ.1) DISPLAY (15,29,'Q',MAX-CHAR+2)
						;SET ACTIVATION ON FIELD WIDTH
INPUT1,
	ACCEPT (15,DCHAR)		; INPUT 1 DECIMAL CHARACTER AT A TIME
	if (dchar.eq.0) go to func
	IF (DCHAR.EQ.8) GO TO ENDFLD	; BACK SPACE OPTION = 'END'
	IF (DCHAR.EQ.9) GO TO TAB	; TAB DEFAULT OPTION
	IF (DCHAR.EQ.10) GO TO ERAEOL	; LINEFEED ERASE TO END OF ENTRY
	IF (DCHAR.EQ.13) GO TO PROCES	; CARRIAGE RETURN - DATA ACCEPTED
	IF (DCHAR.EQ.21) GO TO CLRLIN	; CTRL/U - ERASE LINE
	IF (DCHAR.EQ.23) GO TO ABORT	; CTRL/W - ABORT RECORD
	IF (DCHAR.EQ.27) GO TO ESCAPE	; ESCAPE SEQUENCE TYPED
	IF (DCHAR.EQ.127) GO TO DELETE	; DELETE KEY
	IF (DCHAR.LT.32.OR.DCHAR.GT.122) GO TO INPUT1	
						; IGNORES INVALID CHARACTERS

	IF (CHAR.GT.MAX) GO TO TOOLNG
	IF (COUNT.GT.MAX) GO TO TOOLNG

	XCALL ASCII (DCHAR,ENTRY(CHAR,CHAR))	; CONVERTS CHARACTERS TO ASCII
	WENTRY (CHAR,CHAR) = ENTRY (CHAR,CHAR)
	IF (SYSTM.NE.1) DISPLAY (15,ENTRY(CHAR,CHAR))
	IF (CHAR.GT.COUNT) INCR COUNT		;ONLY INCREASE COUNT OF
						;CHARACTERS IF NEW ONES ADDED
						;RATHER THAN JUST OVERWRITTEN
	INCR CHAR				;NEW CHARACTER ADDED
	GO TO INPUT1
DELETE,				; ERASES 1 CHARACTER ON SCREEN & INSERT DOT
				; IN MAX SPACE
	IF (CHAR.EQ.1) GO TO INVALD
	CHAR = CHAR - 1
	IF (CHAR.LE.COUNT) COUNT = COUNT - 1
	IF (CHAR.GE.MAX) GO TO LASTCH
	ENTRY (CHAR,MAX-1) = ENTRY (CHAR+1,MAX)
	WENTRY (CHAR,MAX-1) = WENTRY (CHAR+1,MAX)
LASTCH,
	ENTRY (MAX,MAX) =
	WENTRY (MAX,MAX) = DOTS
	COL2 = COL + CHAR - 1
	XCALL OUTPT (ROW,COL2,0,WENTRY(CHAR,MAX))
	GO TO INPUT
ENDFLD,					; BRANCH FOR EDITING AFTER CR
	IF (ENDFLG.EQ.0) GO TO INPUT2
	INXCTL = 2
	XCALL OUTPT (ROW,COL,0,'END')
	IF (MAX.GE.4) XCALL OUTPT (0,0,0,BLANKS(1,MAX-3+SPACES))
	GO TO RETRN
ERAEOL,
	IF (TYPE.EQ.'C' .OR. CHAR.GT.MAX) GO TO INPUT2
	ENTRY (CHAR,MAX) =
	WENTRY (CHAR,MAX) = DOTS
	IF (COUNT.GE.CHAR) COUNT = CHAR - 1
	GO TO NOACPT
TAB,			; SETS INXCTL = 3 WHEN TERM CHAR IS TAB & TABFLG = 1
	IF (TABFLG.EQ.0) GO TO INPUT2
	INXCTL = 3
	GO TO RETRN
func,
	xcall ttsts(stat)
	if (stat) accept (15,dchar)
	if (dchar .eq. 059) goto pf1	
	using dchar select
	(059),	goto pf1
	(079),	begin			;<end>
		dchar = 8
		tchar = 53
		goto e
		end
	(133),	begin			;<F11>
		dchar = 8
		tchar = 53
		goto e
		end
	endusing

	goto input

ESCAPE,
	XCALL TTSTS (DCHAR)
	IF (DCHAR.EQ.0) 
	BEGIN
	  DCHAR = 8
	  TCHAR = 53
	  GOTO E
	END
	ACCEPT (15,DCHAR)
	IF (DCHAR.EQ.27) GOTO ESCAPE		;;;
	IF (TERID.GE.6) ACCEPT (15,DCHAR)	;PULL OFF NEXT CHARACTER
	IF ((DCHAR.EQ.68.AND.CHAR.LE.1) .OR. (DCHAR.EQ.67.AND.CHAR.GE.MAX+1))
&	GO TO INVALD
	IF (DCHAR.EQ.68) GO TO LEFT
	IF (DCHAR.EQ.67) GO TO RIGHT
	IF (DCHAR.EQ.82) GO TO INSERT		;PF3 KEY
	IF (DCHAR.EQ.83) GO TO ABORT
	IF (DCHAR.EQ.65) GO TO UPAROW
	IF (DCHAR.EQ.66) GO TO DNAROW
	IF (DCHAR.EQ.80) GO TO PF1
	IF (DCHAR.EQ.81) GO TO PF2
	IF (DCHAR.GE.52.AND.DCHAR.LE.54) GO TO PCMAP	;;; MAP PC KEYS TO MCBA STD
	GO TO INPUT
PCMAP,
	TCHAR = DCHAR
	IF (TCHAR.GT.54.OR.TCHAR.LT.52) GOTO PURBUF
	XCALL TTSTS (DCHAR)
	IF (DCHAR) ACCEPT (15,DCHAR)
	IF (DCHAR.EQ.126) 
	BEGIN
	  IF (TCHAR.EQ.54) DCHAR = 9
	  IF (TCHAR.EQ.53) DCHAR = 8
	  IF (TCHAR.EQ.52) DCHAR = 127
E,
	  GOTO (DELETE,ENDFLD,TAB), TCHAR-51
	END
PURBUF,
	XCALL TTSTS (TCHAR)
	IF (TCHAR) ACCEPT (15,TCHAR)
	IF (TCHAR) GOTO PURBUF
	GOTO INPUT
LEFT,
	CHAR = CHAR - 1
	IF (CHAR.EQ.57) GO TO LFAROW
	GO TO INPUT
RIGHT,
	INCR CHAR
	GO TO INPUT
LFAROW,
	CHAR = CHAR - 7
	GO TO INPUT
UPAROW,
	IF (UPAFLG.EQ.0) GO TO INPUT2
	INXCTL = 4
	IF (TYPE.EQ.'C') GO TO RETRN
	XCALL OUTPT (ROW,COL,0,SAVENT(1,MAX))
	ENTRY = SAVENT
	GO TO RETRN
DNAROW,
	IF (DNAFLG.EQ.0) GO TO INPUT2
	INXCTL = 5
	IF (TYPE.EQ.'C') GO TO RETRN
	XCALL OUTPT (ROW,COL,0,SAVENT(1,MAX))
	ENTRY = SAVENT
	GO TO RETRN
PF1,
	IF (PF1FLG.EQ.0) GO TO INPUT2
	INXCTL = 6
	IF (TYPE.EQ.'C') GO TO RETRN
	XCALL OUTPT (ROW,COL,0,SAVENT(1,MAX))
	ENTRY = SAVENT
	GO TO RETRN
PF2,
	IF (PF2FLG.EQ.0) GO TO INPUT2
	INXCTL = 7
	IF (TYPE.EQ.'C') GO TO RETRN
	XCALL OUTPT (ROW,COL,0,SAVENT(1,MAX))
	ENTRY = SAVENT
	GO TO RETRN
INSERT,
	IF (TYPE.EQ.'C') GO TO INPUT2
	IF (ENTRY(MAX,MAX).NE.BLANKS .OR. CHAR.GE.MAX) DISPLAY (15,7)
	IF (ENTRY(MAX,MAX).NE.BLANKS .OR. CHAR.GE.MAX) GO TO INPUT2
	ENTRY (CHAR+1,MAX) = ENTRY (CHAR,MAX-1)
	ENTRY (CHAR,CHAR) =
	WENTRY (CHAR+1,MAX) = WENTRY (CHAR,MAX-1)
	WENTRY (CHAR,CHAR) =
	IF (CHAR.LE.COUNT) INCR COUNT
	COL2 = COL + CHAR - 1
	XCALL OUTPT (ROW,COL2,0,WENTRY(CHAR,MAX))
	GO TO INPUT
;*********************** Input Processing ******************************
PROCES,
	IF (SYSTM.NE.1) ACCEPT (15,DCHAR)
NOACPT,
	IF (COUNT.LT.MIN) GO TO TOSHRT
	IF (TYPE.EQ.'Y') GO TO TSTANS
	IF (TYPE.EQ.'#'.OR.TYPE.EQ.'N') GO TO TSTNUM
	IF (TYPE.EQ.'D') GO TO TSTDTE
	IF (MODE.EQ.'R' .OR. MODE.EQ.'L') CALL JSTIFY
	IF (TYPE.EQ.'C') GO TO RETRN
	XCALL OUTPT (ROW,COL,0,ENTRY(1,MAX))
	GO TO RETRN
;******************** RIGHT OR LEFT JUSTIFY NUMBER BEFORE PASSING BACK *******
JSTIFY,
	IF (MODE.EQ.'L') GO TO LEFTJ
	ON ERROR NORTJS
	DECMAL = ENTRY
	SUB = MAX + 1
PRELUP,
	SUB = SUB - 1		;SCAN OFF LEADING SPACES BEFORE TESTING
	IF (SUB.LE.0) GO TO NORTJS
	IF (ENTRY(SUB,SUB).EQ.BLANKS) GO TO PRELUP
	SAVSUB = SUB
RITLUP,
	IF (ENTRY(SUB,SUB).EQ.'-' .OR. ENTRY(SUB,SUB).EQ.'+' .OR.
&	ENTRY(SUB,SUB).EQ.BLANKS) GO TO NORTJS		;'-','+' OR ' ' NOT OK
	IF (SUB.LE.1) GO TO RITJUS
	SUB = SUB - 1
	GO TO RITLUP
RITJUS,
	ENTRY (MAX-SAVSUB+1,MAX) = ENTRY (1,SAVSUB)
	IF (MAX-SAVSUB.GT.0) ENTRY (1,MAX-SAVSUB) =
	OFF ERROR
	RETURN
NORTJS,
	OFF ERROR
	RETURN
LEFTJ,
	SUB =
LEFLUP,
	IF (SUB.GE.MAX) GO TO LEFJUS
	INCR SUB
	IF (ENTRY(SUB,SUB).EQ.BLANKS) GO TO LEFLUP
LEFJUS,
	ENTRY (1,MAX-SUB+1) = ENTRY (SUB,MAX)
	IF (MAX.GT.1) ENTRY (MAX-SUB+2,MAX) =
	RETURN
;*********************** Error Messages *******************************
ABORT,					; SETS INXCTL TO 1 FOR ABORT/RESTART
	INXCTL = 1
	MESSGE = '?UT-SCREEN NOT PROCESSED'
	CALL MESSAG
	ENTRY = SAVENT
	GO TO RETRN
TOOLNG,					; ENTRY TOO LONG
	MESSGE = '?UT-TOO MANY CHARACTERS ENTERED'
	IF (ROW.NE.24) CALL MESSAG
	COL2 = COL + MAX
	IF (SYSTM.EQ.1) XCALL OUTPT (ROW,COL2,0,' ')
	GO TO INPUT
BIGNUM,
	MESSGE = '?UT-TOO MANY DIGITS TO LEFT OF DECIMAL POINT'
	IF (ROW.NE.24) CALL MESSAG
	ENTRY = SV2ENT
	GO TO INPUT
BIGDEC,
	MESSGE = '?UT-TOO MANY DIGITS TO RIGHT OF DECIMAL POINT'
	IF (ROW.NE.24) CALL MESSAG
	ENTRY = SV2ENT
	GO TO INPUT
TOSHRT,					; ENTRY TOO SHORT
	MESSGE = '?UT-ENTRY TOO SHORT'
	IF (ROW.NE.24) CALL MESSAG
	GO TO RESET
INVALD,
	DISPLAY (15,7)
	GO TO INPUT

;*************Test for numeric and set explicit decimal point **********

TSTNUM,					; NUMERIC EDITING
	NEG =
	SAVMAX = MAX
	SV2ENT = ENTRY
	ON ERROR DECTST
	DECMAL = ENTRY
	IF (DECMAL.EQ.0.AND.TYPE.NE.'N') XCALL OUTPT (ROW,COL,0,'0')
	IF (DECMAL.LT.0 .AND. MODE.NE.'-') GO TO NOTPOS
	IF (DECMAL.GE.0 .AND. MODE.EQ.'-') SAVMAX = SAVMAX - 1
	IF (NUMDEC) SAVMAX = SAVMAX - 1
	IF (COUNT.GT.SAVMAX) GO TO TOOLNG
	GO TO DSPDEC
DECTST,					;TEST FOR DECIMAL POINT
	IF (NUMDEC.EQ.0 .OR. SAVTYP(3,3).EQ.BLANKS) GO TO BADNUM
	ON ERROR NOTNUM
	SAVSUB =
	SUB =
NUMLUP,						;PULL OUT NEGATIVE SIGNS
	IF (SUB.GE.MAX) GO TO SETDEC
	INCR SUB
	IF (ENTRY(SUB,SUB).EQ.'-') GO TO NEGTIV
	DECMAL = ENTRY (SUB,SUB)
	GO TO NUMLUP
NEGTIV,
	IF (MODE.NE.'-') GO TO NOTPOS
	IF (SUB.LT.MAX) ENTRY (SUB,MAX-1) = ENTRY (SUB+1,MAX)
	ENTRY (MAX,MAX) =
	SUB = SUB - 1
	IF (NEG) GO TO DBLNEG
	NEG = 1
	SAVMAX = SAVMAX - 1		;REDUCE MAX COUNT BY 1
	GO TO NUMLUP
DBLNEG,
	NEG =
	GO TO NUMLUP
NOTNUM,
	IF (ENTRY(SUB,SUB).EQ.DOTS .AND. SAVSUB.NE.0) GO TO BADNUM
								;TOO MANY DOTS
	IF (ENTRY(SUB,SUB).EQ.DOTS .AND. SAVSUB.EQ.0) SAVSUB = SUB
	IF (ENTRY(SUB,SUB).EQ.DOTS) GO TO NUMLUP
	GO TO BADNUM
SETDEC,
	IF (SAVSUB-1.GT.INMAX-NUMDEC) GO TO BIGNUM	;TEST FOR TOO MANY
							;WHOLE NUMBER DIGITS
	SUB = SAVSUB
DECLUP,
	INCR SUB
	IF (SUB.GT.SAVMAX) GO TO CHKDEC
	IF (ENTRY(SUB,SUB).NE.BLANKS) GO TO DECLUP
CHKDEC,
	IF (SUB-SAVSUB-1.LT.NUMDEC) GO TO ADDDEC
	IF (SUB-SAVSUB-1.GT.NUMDEC) GO TO BIGDEC
	ENTRY (SAVSUB,SUB-1) = ENTRY (SAVSUB+1,SUB)
	ENTRY (SUB,SUB) =
	IF (NEG) ENTRY(SUB-1,SUB-1) = '-'
	GO TO DSPDEC
ADDDEC,
	IF (SUB.GT.SAVMAX) GO TO BIGNUM
	ENTRY (SUB,SUB) = '0'
	INCR SUB
	IF (SUB-SAVSUB-1.LT.NUMDEC) GO TO ADDDEC
ADDDON,
	ENTRY (SAVSUB,SUB-1) = ENTRY (SAVSUB+1,SUB)
	ENTRY (SUB,SUB) =
	IF (NEG) ENTRY (SUB-1,SUB-1) = '-'
	GO TO DSPDEC
BADNUM,
	OFF ERROR
	MESSGE = '?UT-MUST BE NUMERIC'
	IF (ROW.NE.24) CALL MESSAG
	ENTRY = SV2ENT
	GO TO INPUT
NOTPOS,
	MESSGE = '?UT-NEGATIVE NOT ALLOWED'
	IF (ROW.NE.24) CALL MESSAG
	ENTRY = SV2ENT
	GO TO INPUT
;******************** Date testing ***************************
TSTDTE,					; EDITING FOR VALID DATE
	ON ERROR BADDTE
	MMDDYY = ENTRY
	IF (MMDDYY.EQ.0 .AND. MIN.EQ.0) GO TO DATEOK
	DAYS (2) = 28
	IF (((YY/4)*4).EQ.YY) DAYS (2) = 29
	IF (MM.LT.1.OR.MM.GT.12) GO TO BADDTE
	IF (DD.LT.1.OR.DD.GT.DAYS(MM)) GO TO BADDTE
	IF (YY.LE.0) GO TO BADDTE
	WENTRY (1,8) = MMDDYY, DATMSK
	XCALL OUTPT (ROW,COL,0,WENTRY(1,8))
DATEOK,
	M=MM
	D=DD
	Y=YY
	IF (MODE.EQ.'N') YYMMDD = MMDDYY	;DON'T CONVERT
	ENTRY (1,6) = YYMMDD, 'XXXXXX'
	GO TO RETRN
BADDTE,
;	MESSGE = '?UT-INVALID DATE. USE FORMAT DDMMYY' ;USE WITH DDMMYY FORMAT
	MESSGE = '?UT-INVALID DATE. USE FORMAT MMDDYY' ;USE WITH MMDDYY FORMAT
	CALL MESSAG
	GO TO CLRLIN
TSTANS,					; EDITING FOR "Y" OR "N" ANSWER
	IF (ENTRY.EQ.' '.AND.MODE.EQ.'Y') ENTRY = 'Y'
	IF (ENTRY.EQ.' '.AND.MODE.EQ.'N') ENTRY = 'N'
	IF (ENTRY.NE.'N' .AND. ENTRY.NE.'Y') GO TO BADANS
	XCALL OUTPT (ROW,COL,0,ENTRY(1,1))
	GO TO RETRN
BADANS,
	DISPLAY (15,7)
	GO TO CLRLIN
DSPDEC,
	MAX = INMAX + 1
	DECMAL = ENTRY
	WENTRY = DECMAL, OUTMSK
	IF (ENTRY.EQ.BLANKS .AND. TYPE.EQ.'N') GO TO NOMSKD
	ENTRY (1,MAX) = DECMAL (20-MAX,18), MSKNEG
NOMSKD,
	MAX = INMAX + 2
	SUB = 20
DSPLUP,
	IF (SUB.GE.50) GO TO BLNKNO
	INCR SUB
	IF (WENTRY(SUB,SUB).EQ.BLANKS) GO TO DSPLUP
DSPNUM,
	WENTRY (1,51-SUB) = WENTRY(SUB,50)
	WENTRY (52-SUB,50) =
BLNKNO,
	XCALL OUTPT (ROW,COL,0,WENTRY(1,MAX))
	GO TO RETRN
MESSAG,
	IF (SYSTM.EQ.1) XCALL FLAGS (00010000,1)	;SUPPRESS CHAR ECHO
							;FOR TSX+
	XCALL OUTPT (24,1,4,MESAG)
	DISPLAY (15,7)
ACCRLF,
	ACCEPT (15,DCHAR)
	IF (DCHAR.NE.13) GO TO ACCRLF
	IF (SYSTM.NE.1) ACCEPT (15,DCHAR)
	XCALL OUTPT (24,1,1,'\')
	IF (SYSTM.EQ.1) XCALL FLAGS (00010000,0)	;REENABLE CHAR. ECHO
							;FOR TSX+
	RETURN
RETRN,
	IF (TYPE.EQ.'L') XCALL FLAGS (10,0)
	RETURN
END
